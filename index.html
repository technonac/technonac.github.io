<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Canon&#39;s Blog</title>
  <meta name="author" content="technonac">
  
  <meta name="description" content="Java,Android Blog">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Canon&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/sandstone.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114131858-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?99f21b353655df817afcb7d4d21a0688";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar  navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Canon&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header ">
  <h1 class="title ">代码改变生活</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-24 </div>
			<div class="article-title"><a href="/2018/02/24/shell-script-6-function/" >shell脚本(6)创建函数</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="基本的脚本函数"><a href="#基本的脚本函数" class="headerlink" title="基本的脚本函数"></a>基本的脚本函数</h2><p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。</p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一种格式采用关键字 <span class="keyword">function</span>：</span><br><span class="line"><span class="keyword">function</span> name &#123; </span><br><span class="line">    commands </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">第二种格式更接近于其他编程语言:</span><br><span class="line"><span class="comment"># 函数名后的空括号表明正在定义的是一个函数</span></span><br><span class="line"><span class="function"><span class="title">name</span></span>() &#123; </span><br><span class="line">commands </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func1 &#123; </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"This is an example of a function"</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">func1 <span class="comment"># 使用函数名调用函数 </span></span><br><span class="line"><span class="comment"># 函数需要先定义后使用</span></span><br><span class="line"><span class="comment"># 同名函数，使用最后定义的函数</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>bash  shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码</p>
<h3 id="默认退出状态码"><a href="#默认退出状态码" class="headerlink" title="默认退出状态码"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量 <code>$?</code>来确定函数的退出状态码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat test4 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing the exit status of a function </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">func1</span></span>() &#123; </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"trying to display a non-existent file"</span> </span><br><span class="line">   ls -l badfile </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testing the function: "</span> </span><br><span class="line">func1 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The exit status is: $?"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test4 </span><br><span class="line">testing the <span class="keyword">function</span>: </span><br><span class="line">trying to display a non-existent file </span><br><span class="line">ls: badfile: No such file or directory </span><br><span class="line">The <span class="built_in">exit</span> status is: 1 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="使用-return-命令"><a href="#使用-return-命令" class="headerlink" title="使用 return 命令"></a>使用 return 命令</h3><p>bash shell使用 return 命令来退出函数并返回特定的退出状态码。 return 命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test5 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the return command in a function </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> dbl &#123; </span><br><span class="line">   <span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"doubling the value"</span> </span><br><span class="line">   <span class="built_in">return</span> $[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">dbl </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The new value is $?"</span> </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 函数一结束就取返回值</span></span><br><span class="line"><span class="comment"># 退出状态码必须是0~255</span></span><br></pre></td></tr></table></figure>
<h3 id="使用函数输出"><a href="#使用函数输出" class="headerlink" title="使用函数输出"></a>使用函数输出</h3><p>可以将函数的输出保存到变量中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test5b </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the echo to return a value </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> dbl &#123; </span><br><span class="line">   <span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value </span><br><span class="line">   <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">result=$(dbl) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The new value is <span class="variable">$result</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test5b </span><br><span class="line">Enter a value: 200 </span><br><span class="line">The new value is 400 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="在函数中使用变量"><a href="#在函数中使用变量" class="headerlink" title="在函数中使用变量"></a>在函数中使用变量</h2><h3 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待,这意味着你可以像普通脚本那样向函数传递参数。函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在 <code>$0</code>变量中定义，函数命令行上的任何参数都会通过 <code>$1</code> 、 <code>$2</code> 等定义。也可以用特殊变量<code>$#</code> 来判断传给函数的参数数目</p>
<p>在脚本中指定函数时，必须将参数和函数放在同一行，像这样： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1 <span class="variable">$value1</span> 10</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># passing parameters to a function </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> addem &#123; </span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ] || [ <span class="variable">$#</span> -gt 2 ] </span><br><span class="line">   <span class="keyword">then</span> </span><br><span class="line">      <span class="built_in">echo</span> -1 </span><br><span class="line">   <span class="keyword">elif</span> [ <span class="variable">$#</span> -eq 1 ] </span><br><span class="line">   <span class="keyword">then</span> </span><br><span class="line">      <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$1</span> ] </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line">   &#125; </span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Adding 10 and 15: "</span> </span><br><span class="line">value=$(addem 10 15) </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$value</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取命令行中的参数 传递给函数</span></span><br><span class="line">$ cat test7 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># trying to access script parameters inside a function </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> func7 &#123; </span><br><span class="line">   <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 2 ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   value=$(func7 <span class="variable">$1</span> <span class="variable">$2</span>) </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The result is <span class="variable">$value</span>"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Usage: badtest1 a b"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test7 </span><br><span class="line">Usage: badtest1 a b </span><br><span class="line">$ ./test7 10 15 </span><br><span class="line">The result is 150 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="在函数中处理变量"><a href="#在函数中处理变量" class="headerlink" title="在函数中处理变量"></a>在函数中处理变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1.全局变量"></a>1.全局变量</h4><p>全局变量是在shell脚本中任何地方都有效的变量。默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test8 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using a global variable to pass a value </span></span><br><span class="line"><span class="keyword">function</span> dbl &#123; </span><br><span class="line">   value=$[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value </span><br><span class="line">dbl </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The new value is: <span class="variable">$value</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test8 </span><br><span class="line">Enter a value: 450 </span><br><span class="line">The new value is: 900 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h4><p>函数内部使用的任何变量都可以被声明成局部变量。定义局部变量时，需要在变量名前加上local关键字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cat test9 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># demonstrating the local keyword </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> func1 &#123; </span><br><span class="line">   <span class="built_in">local</span> temp=$[ <span class="variable">$value</span> + 5 ] </span><br><span class="line">   result=$[ <span class="variable">$temp</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">temp=4 </span><br><span class="line">value=6 </span><br><span class="line"> </span><br><span class="line">func1 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result is <span class="variable">$result</span>"</span> </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$temp</span> -gt <span class="variable">$value</span> ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"temp is larger"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"temp is smaller"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test9 </span><br><span class="line">The result is 22 </span><br><span class="line">temp is smaller </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="数组变量和函数"><a href="#数组变量和函数" class="headerlink" title="数组变量和函数"></a>数组变量和函数</h2><h3 id="向函数传数组参数"><a href="#向函数传数组参数" class="headerlink" title="向函数传数组参数"></a>向函数传数组参数</h3><p>需要将数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test11 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># adding values in an array </span></span><br><span class="line"><span class="keyword">function</span> addarray &#123; </span><br><span class="line">   <span class="built_in">local</span> sum=0 </span><br><span class="line">   <span class="built_in">local</span> newarray </span><br><span class="line">   newarray=($(<span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span>)) </span><br><span class="line">   <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$&#123;newarray[*]&#125;</span> </span><br><span class="line">   <span class="keyword">do</span> </span><br><span class="line">      sum=$[ <span class="variable">$sum</span> + <span class="variable">$value</span> ] </span><br><span class="line">   <span class="keyword">done</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$sum</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">myarray=(1 2 3 4 5) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>"</span> </span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>) </span><br><span class="line">result=$(addarray <span class="variable">$arg1</span>) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result is <span class="variable">$result</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test11 </span><br><span class="line">The original array is: 1 2 3 4 5 </span><br><span class="line">The result is 15 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h3><p>从函数里向shell脚本传回数组变量也用类似的方法。函数用 echo 语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># returning an array value </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> arraydblr &#123; </span><br><span class="line">   <span class="built_in">local</span> origarray </span><br><span class="line">   <span class="built_in">local</span> newarray </span><br><span class="line">   <span class="built_in">local</span> elements </span><br><span class="line">   <span class="built_in">local</span> i </span><br><span class="line">   origarray=($(<span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span>)) </span><br><span class="line">   newarray=($(<span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span>)) </span><br><span class="line">   elements=$[ <span class="variable">$#</span> - 1 ] </span><br><span class="line">   <span class="keyword">for</span> (( i = 0; i &lt;= <span class="variable">$elements</span>; i++ )) </span><br><span class="line">   &#123; </span><br><span class="line">      newarray[<span class="variable">$i</span>]=$[ <span class="variable">$&#123;origarray[$i]&#125;</span> * 2 ] </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$&#123;newarray[*]&#125;</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">myarray=(1 2 3 4 5) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>"</span> </span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>) </span><br><span class="line">result=($(arraydblr <span class="variable">$arg1</span>)) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The new array is: <span class="variable">$&#123;result[*]&#125;</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test12 </span><br><span class="line">The original array is: 1 2 3 4 5 </span><br><span class="line">The new array is: 2 4 6 8 10</span><br></pre></td></tr></table></figure>
<h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阶乘</span></span><br><span class="line">$ cat test13 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using recursion </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> factorial &#123; </span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ] </span><br><span class="line">   <span class="keyword">then</span> </span><br><span class="line">      <span class="built_in">echo</span> 1 </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">local</span> temp=$[ <span class="variable">$1</span> - 1 ] </span><br><span class="line">      <span class="built_in">local</span> result=$(factorial <span class="variable">$temp</span>) </span><br><span class="line">      <span class="built_in">echo</span> $[ <span class="variable">$result</span> * <span class="variable">$1</span> ] </span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line">&#125;   </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter value: "</span> value </span><br><span class="line">result=$(factorial <span class="variable">$value</span>) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The factorial of <span class="variable">$value</span> is: <span class="variable">$result</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test13 </span><br><span class="line">Enter value: 5 </span><br><span class="line">The factorial of 5 is: 120 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><p>bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。</p>
<p>第一步是创建一个包含脚本中所需函数的公用库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat myfuncs </span><br><span class="line"><span class="comment"># my script functions </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> addem &#123; </span><br><span class="line">   <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> multem &#123; </span><br><span class="line">   <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> divem &#123; </span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$2</span> -ne 0 ] </span><br><span class="line">   <span class="keyword">then</span> </span><br><span class="line">      <span class="built_in">echo</span> $[ <span class="variable">$1</span> / <span class="variable">$2</span> ] </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">echo</span> -1 </span><br><span class="line">   <span class="keyword">fi</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。</p>
<p>和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs  shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。</p>
<p>使用函数库的关键在于 source 命令。 source 命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用 source 命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>
<p>source 命令有个快捷的别名，称作点操作符（dot  operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ./myfuncs  <span class="comment"># 第1个点表示点操作符， 第2个点表示当前目录</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat test14 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using functions defined in a library file </span></span><br><span class="line">. ./myfuncs </span><br><span class="line"> </span><br><span class="line">value1=10 </span><br><span class="line">value2=5 </span><br><span class="line">result1=$(addem <span class="variable">$value1</span> <span class="variable">$value2</span>) </span><br><span class="line">result2=$(multem <span class="variable">$value1</span> <span class="variable">$value2</span>) </span><br><span class="line">result3=$(divem <span class="variable">$value1</span> <span class="variable">$value2</span>) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of adding them is: <span class="variable">$result1</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of multiplying them is: <span class="variable">$result2</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of dividing them is: <span class="variable">$result3</span>"</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test14 </span><br><span class="line">The result of adding them is: 15 </span><br><span class="line">The result of multiplying them is: 50 </span><br><span class="line">The result of dividing them is: 2 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="在命令行上使用函数"><a href="#在命令行上使用函数" class="headerlink" title="在命令行上使用函数"></a>在命令行上使用函数</h2><h3 id="在-bashrc-文件中定义函数"><a href="#在-bashrc-文件中定义函数" class="headerlink" title="在.bashrc 文件中定义函数"></a>在.bashrc 文件中定义函数</h3><p>bash shell在每次启动时都会在主目录下查找.bashrc文件并运行</p>
<h4 id="1-直接定义函数"><a href="#1-直接定义函数" class="headerlink" title="1.直接定义函数"></a>1.直接定义函数</h4><p>可以直接在主目录下的.bashrc文件中定义函数。把你写的函数放在文件末尾就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat .bashrc </span><br><span class="line"><span class="comment"># .bashrc </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -r /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line">        . /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 该函数会在下次启动新bash shell时生效。</span></span><br><span class="line"><span class="keyword">function</span> addem &#123; </span><br><span class="line">   <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h4 id="2-读取函数文件"><a href="#2-读取函数文件" class="headerlink" title="2.读取函数文件"></a>2.读取函数文件</h4><p>只要是在shell脚本中，都可以用 source 命令（点操作符）将库文件中的函数添加到你的.bashrc脚本中。shell还会将定义好的函数传给子shell进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat .bashrc </span><br><span class="line"><span class="comment"># .bashrc </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -r /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line">        . /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"> </span><br><span class="line">. /home/rich/libraries/myfuncs </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/24/shell-script-6-function/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-23 </div>
			<div class="article-title"><a href="/2018/02/23/shell-script-5-script-control/" >shell脚本(5)控制脚本</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>Linux利用信号与运行在系统中的进程进行通信。</p>
<h3 id="Linux-信号"><a href="#Linux-信号" class="headerlink" title="Linux 信号"></a>Linux 信号</h3><p>Linux系统和应用程序可以生成超过30个信号，一下是常用的Linux系统信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1  SIGHUP  挂起进程 </span><br><span class="line">2  SIGINT  终止进程</span><br><span class="line">3  SIGQUIT  停止进程 </span><br><span class="line">9  SIGKILL  无条件终止进程 </span><br><span class="line">15  SIGTERM  尽可能终止进程 </span><br><span class="line">17  SIGSTOP  无条件停止进程，但不是终止进程 </span><br><span class="line">18  SIGTSTP  停止或暂停进程，但不终止进程 </span><br><span class="line">19  SIGCONT  继续运行停止的进程</span><br></pre></td></tr></table></figure>
<p>默认情况下，bash shell会忽略收到的任何 <code>SIGQUIT (3)</code> 和 <code>SIGTERM (5)</code>信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的 <code>SIGHUP (1)</code> 和<code>SIGINT (2)</code> 信号。</p>
<p>如果bash  shell收到了 SIGHUP 信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将 SIGHUP 信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。 </p>
<p>通过 SIGINT 信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将 SIGINT 信号传给所有由它所启动的进程，以此告知出现的状况。 </p>
<h3 id="生成信号"><a href="#生成信号" class="headerlink" title="生成信号"></a>生成信号</h3><p>bash  shell允许用键盘上的组合键生成两种基本的Linux信号。</p>
<h4 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h4><p><code>Ctrl</code>+<code>C</code>组合键会生成 <code>SIGINT</code>信号，并将其发送给当前在shell中运行的所有进程。</p>
<h4 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h4><p><code>Ctrl</code>+<code>Z</code>组合键会生成一个 <code>SIGTSTP</code> 信号，停止shell中运行的任何进程。停止（stopping）进程跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>
<h3 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h3><p><code>trap</code>命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了 trap 命令中列出的信号，该信号不再由shell处理，而是交由本地处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trap 命令的格式是： </span></span><br><span class="line"><span class="built_in">trap</span> commands signals</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test1.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Testing signal trapping </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' Sorry! I have trapped Ctrl-C'"</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> This is a <span class="built_in">test</span> script </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 10 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Loop #<span class="variable">$count</span>"</span> </span><br><span class="line">   sleep 1 </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is the end of the test script"</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">$ ./test1.sh </span><br><span class="line">This is a <span class="built_in">test</span> script </span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">^C Sorry! I have trapped Ctrl-C</span><br></pre></td></tr></table></figure>
<h3 id="捕获脚本退出"><a href="#捕获脚本退出" class="headerlink" title="捕获脚本退出"></a>捕获脚本退出</h3><p>要捕获shell脚本的退出，只要在 trap 命令后加上 EXIT 信号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat test2.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Trapping the script exit </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo Goodbye..."</span> EXIT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Loop #<span class="variable">$count</span>"</span> </span><br><span class="line">   sleep 1 </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">$ </span><br><span class="line">$ ./test2.sh </span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">Loop <span class="comment">#4 </span></span><br><span class="line">Loop <span class="comment">#5 </span></span><br><span class="line">Goodbye... </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 提前退出脚本，同样能够捕获到 EXIT</span></span><br><span class="line">$ ./test2.sh </span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">^CGoodbye...</span><br></pre></td></tr></table></figure>
<h3 id="修改或移除捕获"><a href="#修改或移除捕获" class="headerlink" title="修改或移除捕获"></a>修改或移除捕获</h3><p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的 trap 命令。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ cat test3.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Modifying a set trap </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' Sorry... Ctrl-C is trapped.'"</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Loop #<span class="variable">$count</span>"</span> </span><br><span class="line">   sleep 1 </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' I modified the trap!'"</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Second Loop #<span class="variable">$count</span>"</span> </span><br><span class="line">   sleep 1 </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">$ </span><br><span class="line">$ ./test3.sh </span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">^C Sorry... Ctrl-C is trapped. </span><br><span class="line">Loop <span class="comment">#4 </span></span><br><span class="line">Loop <span class="comment">#5 </span></span><br><span class="line">Second Loop <span class="comment">#1 </span></span><br><span class="line">Second Loop <span class="comment">#2 </span></span><br><span class="line">^C I modified the <span class="built_in">trap</span>! </span><br><span class="line">Second Loop <span class="comment">#3 </span></span><br><span class="line">Second Loop <span class="comment">#4 </span></span><br><span class="line">Second Loop <span class="comment">#5 </span></span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已设置好的捕获。在trap 命令与希望恢复默认行为的信号列表之间加上两个破折号</span></span><br><span class="line"><span class="comment"># 也可以在 trap 命令后使用单破折号来恢复信号的默认行为,单破折号和双破折号都可以正常发挥作用。</span></span><br><span class="line"><span class="comment"># Remove the trap </span></span><br><span class="line"><span class="built_in">trap</span> -- SIGINT</span><br></pre></td></tr></table></figure>
<h2 id="以后台模式运行脚本"><a href="#以后台模式运行脚本" class="headerlink" title="以后台模式运行脚本"></a>以后台模式运行脚本</h2><p>在后台模式中，进程运行时不会和终端会话上的 <code>STDIN</code> 、 <code>STDOUT</code>以及<code>STDERR</code>关联</p>
<h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>以后台模式运行shell脚本非常简单。只要在命令后加个<code>&amp;</code>符就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat test4.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Test running in the background </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 10 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   sleep 1 </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">$ </span><br><span class="line">$ ./test4.sh &amp;  <span class="comment"># 将命令作为系统中的一个独立的后台进程运行</span></span><br><span class="line">[1] 3231  <span class="comment"># [shell分配给后台进程的作业号] Linux系统分配给进程的进程ID（PID）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当后台进程结束时，它会在终端上显示出一条消息</span></span><br><span class="line">[1]   Done                    ./test4.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息</span></span><br></pre></td></tr></table></figure>
<h2 id="在非控制台下运行脚本"><a href="#在非控制台下运行脚本" class="headerlink" title="在非控制台下运行脚本"></a>在非控制台下运行脚本</h2><p><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号。这会在退出终端会话时阻止进程退出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ./test1.sh &amp; </span><br><span class="line">[1] 3856 </span><br><span class="line">$ nohup: ignoring input and appending output to <span class="string">'nohup.out'</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 由于 nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为nohup.out的文件中。</span></span><br></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>启动、停止、终止以及恢复作业的这些功能统称为作业控制。</p>
<h3 id="查看作业"><a href="#查看作业" class="headerlink" title="查看作业"></a>查看作业</h3><p>作业控制中的关键命令是 jobs 命令。 jobs 命令允许查看shell当前正在处理的作业。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span> -l </span><br><span class="line">[1]+  1897 Stopped                 ./test10.sh </span><br><span class="line">[2]-  1917 Running                 ./test10.sh &gt; test10.out &amp; </span><br><span class="line"></span><br><span class="line"><span class="comment"># jobs命令参数</span></span><br><span class="line">-l  列出进程的PID以及作业号 </span><br><span class="line">-n  只列出上次shell发出的通知后改变了状态的作业 </span><br><span class="line">-p  只列出作业的PID </span><br><span class="line">-r  只列出运行中的作业 </span><br><span class="line">-s  只列出已停止的作业 </span><br><span class="line"><span class="comment"># +-号解释</span></span><br><span class="line">带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。</span><br><span class="line">当前的默认作业完成处理后，带减号的作业成为下一个默认作业。</span><br><span class="line">任何时候都只有一个带加号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。</span><br></pre></td></tr></table></figure>
<h3 id="重启停止的作业"><a href="#重启停止的作业" class="headerlink" title="重启停止的作业"></a>重启停止的作业</h3><p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。要以后台模式重启一个作业，可用<code>bg</code>命令加上作业号。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./test11.sh </span><br><span class="line">^Z </span><br><span class="line">[1]+  Stopped                 ./test11.sh </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 因为该作业是默认作业（带+号），只需要使用 bg 命令就可以将其以后台模式重启</span></span><br><span class="line">$ <span class="built_in">bg</span> </span><br><span class="line">[1]+ ./test11.sh &amp; </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">jobs</span> </span><br><span class="line">[1]+  Running                 ./test11.sh &amp; </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>要以前台模式重启作业，可用带有作业号的 <code>fg</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">fg</span> 2 </span><br><span class="line">./test12.sh </span><br><span class="line">This is the script<span class="string">'s end... </span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>
<h2 id="调整谦让度"><a href="#调整谦让度" class="headerlink" title="调整谦让度"></a>调整谦让度</h2><p>在多任务操作系统中(Linux)，内核负责将CPU时间分配给系统上运行的每个进程。调度优先级（scheduling  priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。<br>调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。</p>
<h3 id="nice-命令"><a href="#nice-命令" class="headerlink" title="nice 命令"></a>nice 命令</h3><p>nice 命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用 nice的 -n 命令行来指定新的优先级级别。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nice -n 10 ./test4.sh &gt; test4.out &amp; </span><br><span class="line">[1] 4973 </span><br><span class="line">$ </span><br><span class="line">$ ps -p 4973 -o pid,ppid,ni,cmd </span><br><span class="line">  PID  PPID  NI CMD </span><br><span class="line"> 4973  4721  10 /bin/bash ./test4.sh </span><br><span class="line">$</span><br><span class="line"><span class="comment"># nice 命令阻止普通系统用户来提高命令的优先级</span></span><br><span class="line"><span class="comment"># nice命令可以在破折号后面跟上优先级</span></span><br><span class="line">$ nice -10 ./test4.sh &gt; test4.out &amp;</span><br></pre></td></tr></table></figure>
<h3 id="renice-命令"><a href="#renice-命令" class="headerlink" title="renice 命令"></a>renice 命令</h3><p>renice命令可以修改系统上已运行命令的优先级。renice 命令会自动更新当前运行进程的调度优先级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n 指定优先级 -p指定进程号</span></span><br><span class="line">$ renice -n 10 -p 5055 </span><br><span class="line">5055: old priority 0, new priority 10 </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># renice命令有一些限制：</span></span><br><span class="line">1.只能对属于你的进程执行 renice</span><br><span class="line">2.只能通过 renice 降低进程的优先级</span><br><span class="line">3. root用户可以通过 renice 来任意调整进程的优先级</span><br></pre></td></tr></table></figure>
<h2 id="定时运行作业"><a href="#定时运行作业" class="headerlink" title="定时运行作业"></a>定时运行作业</h2><h3 id="用-at-命令来计划执行作业"><a href="#用-at-命令来计划执行作业" class="headerlink" title="用 at 命令来计划执行作业"></a>用 at 命令来计划执行作业</h3><p>​    at 命令允许指定Linux系统何时运行脚本。 at 命令会将作业提交到队列中，指定shell何时运行该作业。 at 的守护进程 atd 会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。</p>
<p>​    atd 守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用 at 命令提交的作业。默认情况下， atd 守护进程会每60秒检查一下这个目录。有作业时， atd 守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配， atd 守护进程就会运行此作业。 </p>
<h4 id="1-at命令的格式"><a href="#1-at命令的格式" class="headerlink" title="1.at命令的格式"></a>1.at命令的格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">at [-f filename] time </span><br><span class="line">----------------------------</span><br><span class="line">默认情况下， at 命令会将 STDIN 的输入放到队列中。用-f参数来指定用于读取命令（脚本文件）的文件名</span><br><span class="line">time 参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过， at 命令会在第二天的那个时间运行指定的作业。</span><br><span class="line">时间格式:</span><br><span class="line">标准的小时和分钟格式，比如10:15。 </span><br><span class="line">AM/PM指示符，比如10:15 PM。 </span><br><span class="line">特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。 </span><br><span class="line">除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。 </span><br><span class="line">标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。 </span><br><span class="line">文本日期，比如Jul 4或Dec 25，加不加年份均可。 </span><br><span class="line">你也可以指定时间增量。 </span><br><span class="line">  当前时间+25 min </span><br><span class="line">  明天10:15 PM </span><br><span class="line">  10:15+7天 </span><br><span class="line">  </span><br><span class="line">作业会被提交到作业队列（job queue）。作业队列会保存通过at命令提交的待处理的作业。</span><br><span class="line">针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a~z和大写字母A~Z来指代。</span><br><span class="line">作业队列的字母排序越高，作业运行的优先级就越低（更高的 nice 值）。默认情况下，at 的作业会被提交到 a作业队列。如果想以更高优先级运行作业，可以用 -q 参数指定不同的队列字母。</span><br></pre></td></tr></table></figure>
<h4 id="2-获取作业的输出"><a href="#2-获取作业的输出" class="headerlink" title="2.获取作业的输出"></a>2.获取作业的输出</h4><p>当作业在Linux系统上运行时，显示器并不会关联到该作业。Linux系统会将提交该作业的用户的电子邮件地址作为 STDOUT 和 STDERR 。任何发到 STDOUT 或 STDERR 的输出都会通过邮件系统发送给该用户。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ at -f test13.sh now </span><br><span class="line"><span class="comment"># at 命令利用 sendmail 应用程序来发送邮件。最好在脚本中对 STDOUT 和 STDERR 进行重定向</span></span><br></pre></td></tr></table></figure>
<h4 id="3-列出等待的作业"><a href="#3-列出等待的作业" class="headerlink" title="3.列出等待的作业"></a>3.列出等待的作业</h4><p>atq 命令可以查看系统中有哪些作业在等待。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ atq </span><br><span class="line">20      2015-07-14 13:03 = Christine</span><br></pre></td></tr></table></figure>
<h4 id="4-删除作业"><a href="#4-删除作业" class="headerlink" title="4.删除作业"></a>4.删除作业</h4><p>atrm 命令来删除等待中的作业</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ atq </span><br><span class="line">18      2015-07-15 13:03 a Christine </span><br><span class="line">17      2015-07-14 16:00 a Christine </span><br><span class="line">19      2015-07-14 13:30 a Christine </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 指定想要删除的作业号</span></span><br><span class="line"><span class="comment"># 只能删除你提交的作业</span></span><br><span class="line">$ atrm 18 </span><br><span class="line">$ </span><br><span class="line">$ atq </span><br><span class="line">17      2015-07-14 16:00 a Christine </span><br><span class="line">19      2015-07-14 13:30 a Christine </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="安排需要定期执行的脚本"><a href="#安排需要定期执行的脚本" class="headerlink" title="安排需要定期执行的脚本"></a>安排需要定期执行的脚本</h3><p>Linux系统使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。</p>
<h4 id="1-cron时间表"><a href="#1-cron时间表" class="headerlink" title="1.cron时间表"></a>1.cron时间表</h4><p>cron时间表采用一种特别的格式来指定作业何时运行。其格式如下： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">min hour dayofmonth month dayofweek <span class="built_in">command</span></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项。</span><br><span class="line">*通配符</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天的10:15运行一个命令</span></span><br><span class="line">15 10 * * * <span class="built_in">command</span> </span><br><span class="line"><span class="comment"># 每周一4:15 PM运行的命令</span></span><br><span class="line">15 16 * * 1 <span class="built_in">command</span></span><br><span class="line"><span class="comment"># 命令列表必须指定要运行的命令或脚本的全路径名</span></span><br><span class="line">15 10 * * * /home/rich/test4.sh &gt; test4out</span><br></pre></td></tr></table></figure>
<h4 id="2-构建cron时间表"><a href="#2-构建cron时间表" class="headerlink" title="2.构建cron时间表"></a>2.构建cron时间表</h4><p>每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了 crontab 命令来处理cron时间表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l </span><br><span class="line">no crontab <span class="keyword">for</span> rich </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 默认情况下，用户的cron时间表文件并不存在。</span></span><br><span class="line"><span class="comment"># 要为cron时间表添加条目，可以用 -e 选项。在添加条目时， crontab 命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容（或者是一个空文件，如果时间表不存在的话） </span></span><br><span class="line"><span class="variable">$crontab</span> -e</span><br></pre></td></tr></table></figure>
<h4 id="3-浏览cron目录"><a href="#3-浏览cron目录" class="headerlink" title="3.浏览cron目录"></a>3.浏览cron目录</h4><p>如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/cron.*ly </span><br><span class="line">/etc/cron.daily: </span><br><span class="line">/etc/cron.hourly: </span><br><span class="line">/etc/cron.monthly:</span><br><span class="line">/etc/cron.weekly: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它</span></span><br></pre></td></tr></table></figure>
<h4 id="4-anacron程序"><a href="#4-anacron程序" class="headerlink" title="4.anacron程序"></a>4.anacron程序</h4><p>cron程序的唯一问题是它假定Linux系统是7×24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。</p>
<p>如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。</p>
<p>anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/ anacron</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /var/spool/anacron/cron.monthly </span><br><span class="line">20150626 </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。</span></span><br><span class="line">$ sudo cat /etc/anacrontab </span><br><span class="line"><span class="comment">#period in days   delay in minutes   job-identifier   command </span></span><br><span class="line">1       5       cron.daily              nice run-parts /etc/cron.daily </span><br><span class="line"></span><br><span class="line">anacron时间表的基本格式： </span><br><span class="line">period delay identifier <span class="built_in">command</span> </span><br><span class="line"><span class="comment"># run-parts程序负责运行目录中传给它的任何脚本</span></span><br><span class="line"><span class="comment"># anacron不会运行位于/etc/cron.hourly的脚本。程序不会处理执行时间需求小于一天的脚本。</span></span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/23/shell-script-5-script-control/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-22 </div>
			<div class="article-title"><a href="/2018/02/22/shell-script-4-presenting-data/" >shell脚本(4)呈现数据</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="理解输入和输出"><a href="#理解输入和输出" class="headerlink" title="理解输入和输出"></a>理解输入和输出</h2><p>目前有两种显示脚本输出的方法： 1.在显示器屏幕上显示输出 2.将输出重定向到文件中 </p>
<h3 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h3><p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file  descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（ 0 、 1 和 2 ）</p>
<p> Linux的标准文件描述符</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩 写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<h4 id="1-STDIN"><a href="#1-STDIN" class="headerlink" title="1.STDIN"></a>1.STDIN</h4><p><code>STDIN</code>文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从<code>STDIN</code>文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>
<p>在使用输入重定向符号（ &lt; ）时，Linux会用重定向指定的文件来替换标准输入文件描述符,许多bash命令能接受 STDIN 的输入，尤其是没有在命令行上指定文件的话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出一行。</span></span><br><span class="line">$ cat </span><br><span class="line">this is a <span class="built_in">test</span> </span><br><span class="line">this is a <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 重定向 用testfile文件中的行作为输入</span></span><br><span class="line">$ cat &lt; testfile</span><br></pre></td></tr></table></figure>
<h4 id="2-STDOUT"><a href="#2-STDOUT" class="headerlink" title="2.STDOUT"></a>2.STDOUT</h4><p><code>STDOUT</code> 文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向 <code>STDOUT</code>文件描述符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出重定向</span></span><br><span class="line">$ ls -l &gt; test2 </span><br><span class="line"><span class="comment"># 输出追加</span></span><br><span class="line">$ who &gt;&gt; test2 </span><br><span class="line"><span class="comment"># 输出错误时</span></span><br><span class="line">$ ls -al badfile &gt; test3 </span><br><span class="line">ls: cannot access badfile: No such file or directory </span><br><span class="line">$ cat test3 </span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line">当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。 </span><br><span class="line">shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。</span><br></pre></td></tr></table></figure>
<h4 id="3-STDERR"><a href="#3-STDERR" class="headerlink" title="3.STDERR"></a>3.STDERR</h4><p>shell通过特殊的 <code>STDERR</code> 文件描述符来处理错误消息。<code>STDERR</code>文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。 默认情况下， <code>STDERR</code>文件描述符会和 <code>STDOUT</code>文件描述符指向同样的地方。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p>
<h3 id="重定向错误"><a href="#重定向错误" class="headerlink" title="重定向错误"></a>重定向错误</h3><h4 id="1-只重定向错误"><a href="#1-只重定向错误" class="headerlink" title="1.只重定向错误"></a>1.只重定向错误</h4><p><code>STDERR</code>文件描述符被设成 2 。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al badfile 2&gt; test4 </span><br><span class="line">$ cat test4 </span><br><span class="line">ls: cannot access badfile: No such file or directory </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 只有错误消息被重定向到文件</span></span><br><span class="line">$ ls -al <span class="built_in">test</span> badtest test2 2&gt; test5 </span><br><span class="line">-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 </span><br><span class="line">$ cat test5 </span><br><span class="line">ls: cannot access <span class="built_in">test</span>: No such file or directory </span><br><span class="line">ls: cannot access badtest: No such file or directory </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h4 id="2-重定向错误和数据"><a href="#2-重定向错误和数据" class="headerlink" title="2. 重定向错误和数据"></a>2. 重定向错误和数据</h4><p>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常输出STDOUT 重定向到test7文件</span></span><br><span class="line"><span class="comment"># 错误消息STDERR 重定向到test6文件</span></span><br><span class="line">$ ls -al <span class="built_in">test</span> test2 test3 badtest 2&gt; test6 1&gt; test7 </span><br><span class="line">$ cat test6 </span><br><span class="line">ls: cannot access <span class="built_in">test</span>: No such file or directory </span><br><span class="line">ls: cannot access badtest: No such file or directory </span><br><span class="line">$ cat test7 </span><br><span class="line">-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 </span><br><span class="line">-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 </span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将STDERR和STDOUT的输出重定向到同一个输出文件,使用特殊的重定向符号 &amp;&gt;</span></span><br><span class="line">$ ls -al <span class="built_in">test</span> test2 test3 badtest &amp;&gt; test7 </span><br><span class="line">$ cat test7 </span><br><span class="line">ls: cannot access <span class="built_in">test</span>: No such file or directory </span><br><span class="line">ls: cannot access badtest: No such file or directory </span><br><span class="line">-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 </span><br><span class="line">-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 当使用 &amp;&gt; 符时，命令生成的所有输出都会发送到同一位置，包括数据和错误。</span></span><br><span class="line"><span class="comment"># 为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。</span></span><br></pre></td></tr></table></figure>
<h2 id="在脚本中重定向输出"><a href="#在脚本中重定向输出" class="headerlink" title="在脚本中重定向输出"></a>在脚本中重定向输出</h2><h3 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h3><p>如果想在脚本中生成错误消息，可以将单独的一行输出重定向到 STDERR 。使用输出重定向符来将输出信息重定向到 STDERR 文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个 &amp;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat test8 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing STDERR messages </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is an error"</span> &gt;&amp;2 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is normal output"</span> </span><br><span class="line">$ </span><br><span class="line">$ ./test8 </span><br><span class="line">This is an error </span><br><span class="line">This is normal output </span><br><span class="line"><span class="comment"># 默认情况下，Linux会将 STDERR 导向 STDOUT 。所以上面的结果输出正常，但是，如果你在运行脚本时重定向了STDERR ，脚本中所有导向 STDERR 的文本都会被重定向。</span></span><br><span class="line"></span><br><span class="line">$ ./test8 2&gt; test9 </span><br><span class="line">This is normal output </span><br><span class="line">$ cat test9 </span><br><span class="line">This is an error </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个 echo 语句就会很烦琐。可以用 exec 命令告诉shell在脚本执行期间重定向某个特定文件描述符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting all output to a file </span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;testout </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is a test of redirecting all output"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"from a script to another file."</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"without having to redirect every individual line"</span> </span><br><span class="line">$ ./test10 </span><br><span class="line">$ cat testout </span><br><span class="line">This is a <span class="built_in">test</span> of redirecting all output </span><br><span class="line">from a script to another file. </span><br><span class="line">without having to redirect every individual line </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># exec 命令会启动一个新shell并将 STDOUT 文件描述符重定向到文件。脚本中发给 STDOUT 的所有输出会被重定向到文件。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以在脚本执行过程中重定向 STDOUT</span></span><br><span class="line">$ cat test11 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting output to different locations </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> 2&gt;testerror </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is the start of the script"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"now redirecting all output to another location"</span> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">exec</span> 1&gt;testout </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This output should go to the testout file"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"but this should go to the testerror file"</span> &gt;&amp;2 </span><br><span class="line">$ </span><br><span class="line">$ ./test11 </span><br><span class="line">This is the start of the script </span><br><span class="line">now redirecting all output to another location </span><br><span class="line">$ cat testout </span><br><span class="line">This output should go to the testout file </span><br><span class="line">$ cat testerror </span><br><span class="line">but this should go to the testerror file </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="在脚本中重定向输入"><a href="#在脚本中重定向输入" class="headerlink" title="在脚本中重定向输入"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向 STDOUT 和 STDERR 相同的方法来将 STDIN 从键盘重定向到其他位置。 exec 命令允许你将 STDIN 重定向到Linux系统上的文件中.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting file input </span></span><br><span class="line"><span class="comment"># 重定向输入，从文件testfile中获得输入，而不是STDIN</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt; testfile </span><br><span class="line">count=1 </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Line #<span class="variable">$count</span>: <span class="variable">$line</span>"</span> </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line">$ ./test12 </span><br><span class="line">Line <span class="comment">#1: This is the first line. </span></span><br><span class="line">Line <span class="comment">#2: This is the second line. </span></span><br><span class="line">Line <span class="comment">#3: This is the third line.</span></span><br></pre></td></tr></table></figure>
<h2 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h2><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h3 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h3><p>使用 exec 命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test13 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using an alternative file descriptor </span></span><br><span class="line"><span class="comment"># 将文件描述符3 重定向到另一个文件</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;test13out </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This should display on the monitor"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"and this should be stored in the file"</span> &gt;&amp;3 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Then this should be back on the monitor"</span> </span><br><span class="line">$ ./test13 </span><br><span class="line">This should display on the monitor </span><br><span class="line">Then this should be back on the monitor </span><br><span class="line">$ cat test13out </span><br><span class="line">and this should be stored <span class="keyword">in</span> the file </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="重定向文件描述符"><a href="#重定向文件描述符" class="headerlink" title="重定向文件描述符"></a>重定向文件描述符</h3><p>如果要恢复已重定向的文件描述符，你可以分配另外一个文件描述符给标准文件描述符。这意味着你可以将 STDOUT 的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回 STDOUT。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat test14 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># storing STDOUT, then coming back to it </span></span><br><span class="line"><span class="comment"># 将文件描述符 3 重定向到文件描述符1的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;1 </span><br><span class="line"><span class="comment"># 将STDOUT重定向到文件，shell现在会将发送给STDOUT 的输出直接重定向到输出文件中。但是，文件描述符 3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;test14out </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This should store in the output file"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"along with this line."</span> </span><br><span class="line"><span class="comment"># 在向 STDOUT （现在指向一个文件）发送一些输出之后，脚本将 STDOUT 重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在 STDOUT 又指向了它原来的位置：显示器。 </span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;&amp;3 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Now things should be back to normal"</span> </span><br><span class="line">$ </span><br><span class="line">$ ./test14 </span><br><span class="line">Now things should be back to normal </span><br><span class="line">$ cat test14out </span><br><span class="line">This should store <span class="keyword">in</span> the output file </span><br><span class="line">along with this line. </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="创建输入文件描述符"><a href="#创建输入文件描述符" class="headerlink" title="创建输入文件描述符"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat test15 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting input file descriptors </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件描述符6用来保存 STDIN 的位置</span></span><br><span class="line"><span class="built_in">exec</span> 6&lt;&amp;0 </span><br><span class="line"><span class="comment"># 将 STDIN 重定向到一个文件,read 命令的所有输入都来自重定向后的 STDIN （也就是输入文件）。</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt; testfile </span><br><span class="line"> </span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Line #<span class="variable">$count</span>: <span class="variable">$line</span>"</span> </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># 将 STDIN 重定向到文件描述符 6 ，从而将STDIN恢复到原先的位置。</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt;&amp;6 </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Are you done now? "</span> answer </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span> </span><br><span class="line">Y|y) <span class="built_in">echo</span> <span class="string">"Goodbye"</span>;; </span><br><span class="line">N|n) <span class="built_in">echo</span> <span class="string">"Sorry, this is the end."</span>;; </span><br><span class="line"><span class="keyword">esac</span> </span><br><span class="line">$ ./test15 </span><br><span class="line">Line <span class="comment">#1: This is the first line. </span></span><br><span class="line">Line <span class="comment">#2: This is the second line. </span></span><br><span class="line">Line <span class="comment">#3: This is the third line. </span></span><br><span class="line">Are you <span class="keyword">done</span> now? y </span><br><span class="line">Goodbye</span><br></pre></td></tr></table></figure>
<h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符.</p>
<p>要关闭文件描述符，将它重定向到特殊符号 <code>&amp;-</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭文件描述符 3 ，不再在脚本中使用它</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat badtest </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing closing file descriptors </span></span><br><span class="line"><span class="built_in">exec</span> 3&gt; test17file </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is a test line of data"</span> &gt;&amp;3 </span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;- </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This won't work"</span> &gt;&amp;3 </span><br><span class="line">$ ./badtest </span><br><span class="line">./badtest: 3: Bad file descriptor </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="headerlink" title="列出打开的文件描述符"></a>列出打开的文件描述符</h2><p>lsof 命令会列出整个Linux系统打开的所有文件描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/sbin/lsof -a -p $$ -d 0,1,2 </span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME </span><br><span class="line">bash    3344 rich    0u   CHR  136,0         2 /dev/pts/0 </span><br><span class="line">bash    3344 rich    1u   CHR  136,0         2 /dev/pts/0 </span><br><span class="line">bash    3344 rich    2u   CHR  136,0         2 /dev/pts/0 </span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">-p 指定进程ID,PID</span><br><span class="line">-d 指定要显示的文件描述符编号</span><br><span class="line">-a 对两个选项结果进行AND运算</span><br><span class="line">$$ 当前pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsof的默认输出 </span></span><br><span class="line">COMMAND  正在运行的命令名的前9个字符 </span><br><span class="line">PID  进程的PID </span><br><span class="line">USER  进程属主的登录名 </span><br><span class="line">FD  文件描述符号以及访问类型（r代表读，w代表写，u代表读写） </span><br><span class="line">TYPE  文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件） </span><br><span class="line">DEVICE  设备的设备号（主设备号和从设备号）</span><br><span class="line">SIZE  如果有的话，表示文件的大小 </span><br><span class="line">NODE  本地文件的节点号 </span><br><span class="line">NAME  文件名 </span><br><span class="line"></span><br><span class="line">与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名。</span><br></pre></td></tr></table></figure>
<h2 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h2><p>可以将 <code>STDERR</code> 重定向到一个叫作null文件的特殊文件。null文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。<br>在Linux系统上null文件的标准位置是<code>/dev/null</code>。你重定向到该位置的任何数据都会被丢掉，不会显示。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al &gt; /dev/null </span><br><span class="line">$ cat /dev/null </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 避免错误消息</span></span><br><span class="line">$ ls -al badfile test16 2&gt; /dev/null </span><br><span class="line">-rwxr--r--    1 rich     rich          135 Oct 29 19:57 test16* </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 快速清除现有文件的数据,清除日志文件的常用方法</span></span><br><span class="line">$ cat /dev/null &gt; testfile </span><br><span class="line">$ cat testfile </span><br><span class="line">$ 清除日志文件的一个常用方法</span><br></pre></td></tr></table></figure>
<h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>Linux系统有特殊的目录，专供临时文件使用。Linux使用<code>/tmp</code>目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除<code>/tmp</code>目录的所有文件。系统上的任何用户账户都有权限在读写<code>/tmp</code>目录中的文件。有个特殊命令可以用来创建临时文件。 <code>mktemp</code>命令可以在<code>/tmp</code>目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的<code>umask</code> 值。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。</p>
<h3 id="创建本地临时文件"><a href="#创建本地临时文件" class="headerlink" title="创建本地临时文件"></a>创建本地临时文件</h3><p>默认情况下， <code>mktemp</code> 会在本地目录中创建一个文件。要用 <code>mktemp</code> 命令在本地目录中创建一个临时文件，你需要指定一个文件名模板。模板可以包含任意文本文件名，在文件名末尾加上6个 X </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mktemp testing.XXXXXX </span><br><span class="line">testing.1DRLuV </span><br><span class="line"></span><br><span class="line"><span class="comment"># shell脚本中保存文件名称</span></span><br><span class="line">tempfile=$(mktemp test.XXXXXX)</span><br></pre></td></tr></table></figure>
<h3 id="在-tmp-目录创建临时文件"><a href="#在-tmp-目录创建临时文件" class="headerlink" title="在/tmp 目录创建临时文件"></a>在/tmp 目录创建临时文件</h3><p> <code>mktemp</code> 命令使用<code>-t</code> 选项在系统的临时目录来创建临时文件。创建好后会返回用来创建临时文件的全路径，而不是只有文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mktemp -t test.XXXXXX </span><br><span class="line">/tmp/test.xG3374 </span><br><span class="line">$ ls -al /tmp/<span class="built_in">test</span>* </span><br><span class="line">-rw------- 1 rich rich 0 2014-10-29 18:41 /tmp/test.xG3374 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h3><p><code>mktemp</code> 命令-d 选项来创建一个临时目录而不是临时文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tempdir=$(mktemp -d dir.XXXXXX) </span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$tempdir</span> </span><br><span class="line">tempfile1=$(mktemp temp.XXXXXX) </span><br><span class="line">tempfile2=$(mktemp temp.XXXXXX)</span><br></pre></td></tr></table></figure>
<h2 id="记录消息-tee"><a href="#记录消息-tee" class="headerlink" title="记录消息 (tee)"></a>记录消息 (tee)</h2><p>如果需要将输出同时发送到显示器和日志文件，只要用特殊的 tee 命令就行。<br>tee 命令相当于管道的一个T型接头。它将从 STDIN 过来的数据同时发往两处。一处是STDOUT ，另一处是 tee 命令行所指定的文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tee filename</span><br><span class="line">-a 将数据追加到文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出。 </span></span><br><span class="line">$ date | tee testfile </span><br><span class="line">Sun Oct 19 18:56:21 EDT 2014 </span><br><span class="line">$ cat testfile </span><br><span class="line">Sun Oct 19 18:56:21 EDT 2014 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/22/shell-script-4-presenting-data/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-21 </div>
			<div class="article-title"><a href="/2018/02/21/shell-script-3-user-input/" >shell脚本(3)处理用户输入</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>bash shell提供了一些不同的方法来从用户处获得数据，包括命令行参数(添加在命令后的数据)、命令行选项(可修改命令行为的单个字母)以及键盘输入</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h3 id="读取参数"><a href="#读取参数" class="headerlink" title="读取参数"></a>读取参数</h3><p>bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的所有参数位置参数变量是标准的数字:<code>$0</code>是程序名,<code>$1</code>是第一个参数,<code>$2</code> 是第二个参数,依次类推,直到第九个参数<code>$9</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test2.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># testing two command line parameters</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">total=$[ <span class="variable">$1</span> * <span class="variable">$2</span> ]</span><br><span class="line"><span class="built_in">echo</span> The first parameter is <span class="variable">$1</span>.</span><br><span class="line"><span class="built_in">echo</span> The second parameter is <span class="variable">$2</span>.</span><br><span class="line"><span class="built_in">echo</span> The total value is <span class="variable">$total</span>.</span><br><span class="line">$ </span><br><span class="line">$ ./test2.sh 2 5</span><br><span class="line">The first parameter is 2.</span><br><span class="line">The second parameter is 5.</span><br><span class="line">The total value is 10.</span><br></pre></td></tr></table></figure>
<p>每个参数都是用空格分隔的，要在参数值中包含空格，必须要用引号(单引号或双引号均可)<br>如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如<code>${10}</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat test4.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># handling lots of parameters </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">total=$[ <span class="variable">$&#123;10&#125;</span> * <span class="variable">$&#123;11&#125;</span> ] </span><br><span class="line"><span class="built_in">echo</span> The tenth parameter is <span class="variable">$&#123;10&#125;</span> </span><br><span class="line"><span class="built_in">echo</span> The eleventh parameter is <span class="variable">$&#123;11&#125;</span> </span><br><span class="line"><span class="built_in">echo</span> The total is <span class="variable">$total</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12 </span><br><span class="line">The tenth parameter is 10 </span><br><span class="line">The eleventh parameter is 11 </span><br><span class="line">The total is 110 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="读取脚本名"><a href="#读取脚本名" class="headerlink" title="读取脚本名"></a>读取脚本名</h3><p>用<code>$0</code>参数获取shell在命令行启动的脚本名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test5b.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># Using basename with the $0 parameter</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">name=$(basename <span class="variable">$0</span>) <span class="comment"># basename 命令会返回不包含路径的脚本名</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> The script name is: <span class="variable">$name</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">$ bash /home/Christine/test5b.sh </span><br><span class="line">The script name is: test5b.sh </span><br><span class="line">$ ./test5b.sh </span><br><span class="line">The script name is: test5b.sh</span><br></pre></td></tr></table></figure>
<h3 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a>测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test7.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing parameters before use </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]  <span class="comment"># -n测试来检查命令行参数 $1 中是否有数据</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> Hello <span class="variable">$1</span>, glad to meet you. </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Sorry, you did not identify yourself. "</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h2><h3 id="参数统计"><a href="#参数统计" class="headerlink" title="参数统计"></a>参数统计</h3><p>特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test8.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># getting the number of parameters </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> There were <span class="variable">$#</span> parameters supplied. </span><br><span class="line">$  </span><br><span class="line">$ ./test8.sh </span><br><span class="line">There were 0 parameters supplied. </span><br><span class="line">$  </span><br><span class="line">$ ./test8.sh 1 2 3 4 5 </span><br><span class="line">There were 5 parameters supplied.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最后一个参数 $&#123;!#&#125;</span></span><br><span class="line"></span><br><span class="line">$ cat test10.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># Grabbing the last parameter</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">params=<span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$params</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$&#123;!#&#125;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">$ bash test10.sh 1 2 3 4 5 </span><br><span class="line">The last parameter is 5 </span><br><span class="line">The last parameter is 5 </span><br><span class="line"></span><br><span class="line">$ bash test10.sh </span><br><span class="line">The last parameter is 0 </span><br><span class="line">The last parameter is test10.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，当命令行上没有任何参数时，$#的值为 0 ，params 变量的值也一样，但$&#123;!#&#125;变量会返回命令行用到的脚本名</span></span><br></pre></td></tr></table></figure>
<h3 id="抓取所有的数据"><a href="#抓取所有的数据" class="headerlink" title="抓取所有的数据"></a>抓取所有的数据</h3><p><code>$*</code>和 <code>$@</code>变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数</p>
<p><code>$*</code> 变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的一个参数值。基本上<code>$*</code> 变量会将这些参数视为一个整体，而不是多个个体。</p>
<p><code>$@</code> 变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过 for 命令完成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># testing $* and $@</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">count=1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"\$* Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>"</span></span><br><span class="line">  count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">count=1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"\$@ Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>"</span></span><br><span class="line">  count=$[ <span class="variable">$count</span> + 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ </span><br><span class="line">$ ./test12.sh rich barbara katie jessica</span><br><span class="line"> </span><br><span class="line">$* Parameter <span class="comment">#1 = rich barbara katie jessica</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#1 = rich</span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#2 = barbara</span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#3 = katie</span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#4 = jessica</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>

	
	</div>
  <a type="button" href="/2018/02/21/shell-script-3-user-input/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-20 </div>
			<div class="article-title"><a href="/2018/02/20/shell-script-2-structed-command/" >shell脚本(2)结构化命令</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>逻辑流程控制通常称为结构化命令(structured command)</p>
<h2 id="使用-if-then-语句"><a href="#使用-if-then-语句" class="headerlink" title="使用 if-then 语句"></a>使用 if-then 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>bash shell的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于 then 部分的命令就会被执行,如果该命令的退出状态码是其他值， then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat test1.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># testing the if statement</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">pwd</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"It worked"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>if-then 语句的另一种形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">commands </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then-else 语句"></a>if-then-else 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 if</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> command1 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">command</span> <span class="built_in">set</span> 1 </span><br><span class="line"><span class="keyword">elif</span> command2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">command</span> <span class="built_in">set</span> 2 </span><br><span class="line"><span class="keyword">elif</span> command3 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">command</span> <span class="built_in">set</span> 3 </span><br><span class="line"><span class="keyword">elif</span> command4 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">command</span> <span class="built_in">set</span> 4 </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h2><p>test 命令提供了在 if-then 语句中测试不同条件的途径,如果 test 命令中列出的条件成立,test 命令就会退出并返回退出状态码0。<br>test 命令的格式非常简单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> condition</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p> 判断内容是否为空</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat test6.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Testing the test command </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">my_variable=<span class="string">""</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$my_variable</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The <span class="variable">$my_variable</span> expression returns a True"</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The <span class="variable">$my_variable</span> expression returns a False"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$ </span><br><span class="line">$ ./test6.sh </span><br><span class="line">The  expression returns a False </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>bash shell提供了另一种条件测试方法，无需在 if-then 语句中声明 test 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</span></span><br></pre></td></tr></table></figure>
<p>test 命令可以判断三类条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数值比较</span><br><span class="line">字符串比较</span><br><span class="line">文件比较</span><br></pre></td></tr></table></figure>
<h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><p>test命令的数值比较功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n1 -eq n2  检查n1是否与n2相等</span><br><span class="line">n1 -ge n2  检查n1是否大于或等于n2 </span><br><span class="line">n1 -gt n2  检查n1是否大于n2 </span><br><span class="line">n1 -le n2  检查n1是否小于或等于n2 </span><br><span class="line">n1 -lt n2  检查n1是否小于n2 </span><br><span class="line">n1 -ne n2  检查n1是否不等于n2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat numeric_test.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># Using numeric test evaluations</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">value1=10</span><br><span class="line">value2=11</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$value1</span> -gt 5 ] <span class="comment"># 测试变量 value1 的值是否大于 5</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The test value <span class="variable">$value1</span> is greater than 5"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$value1</span> -eq <span class="variable">$value2</span> ] <span class="comment"># 测试变量 value1 的值是否和变量 value2 的值相等</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The values are equal"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The values are different"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串比较测试 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2   检查str1是否和str2相同</span><br><span class="line">str1 != str2  检查str1是否和str2不同</span><br><span class="line">str1 &lt; str2   检查str1是否比str2小</span><br><span class="line">str1 &gt; str2   检查str1是否比str2大</span><br><span class="line">-n str1       检查str1的长度是否非0</span><br><span class="line">-z str1       检查str1的长度是否为0</span><br></pre></td></tr></table></figure>
<h4 id="1-字符串相等性"><a href="#1-字符串相等性" class="headerlink" title="1.字符串相等性"></a>1.字符串相等性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test7.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing string equality </span></span><br><span class="line">testuser=rich </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="variable">$testuser</span> ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Welcome <span class="variable">$testuser</span>"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test7.sh </span><br><span class="line">Welcome rich </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>记住，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p>
<h4 id="2-字符串顺序"><a href="#2-字符串顺序" class="headerlink" title="2.字符串顺序"></a>2.字符串顺序</h4><p>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名；<br>大于和小于顺序和 sort 命令所采用的不同。</p>
<p>比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。 sort命令使用的是系统的本地化语言设置中定义的排序顺序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test9.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># mis-using string comparisons</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">val1=baseball</span><br><span class="line">val2=hockey</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$val1</span> \&gt; <span class="variable">$val2</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$val1</span> is greater than <span class="variable">$val2</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$val1</span> is less than <span class="variable">$val2</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注意,test 命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较</p>
<h4 id="3-字符串大小"><a href="#3-字符串大小" class="headerlink" title="3.字符串大小"></a>3.字符串大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing string length </span></span><br><span class="line">val1=testing </span><br><span class="line">val2=<span class="string">''</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$val1</span> ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val1</span>' is not empty"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val1</span>' is empty"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$val2</span> ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val2</span>' is empty"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val2</span>' is not empty"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$val3</span> ] <span class="comment"># 未被定义过，长度为0</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val3</span>' is empty"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The string '<span class="variable">$val3</span>' is not empty"</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">$  </span><br><span class="line">$ ./test10.sh </span><br><span class="line">The string <span class="string">'testing'</span> is not empty </span><br><span class="line">The string <span class="string">''</span> is empty </span><br><span class="line">The string <span class="string">''</span> is empty </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3><p>文件比较是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。</p>
<p>test命令的文件比较功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-d file  检查file是否存在并是一个目录</span><br><span class="line">-e file  检查file是否存在</span><br><span class="line">-f file  检查file是否存在并是一个文件</span><br><span class="line">-r file  检查file是否存在并可读</span><br><span class="line">-s file  检查file是否存在并非空</span><br><span class="line">-w file  检查file是否存在并可写</span><br><span class="line">-x file  检查file是否存在并可执行</span><br><span class="line">-O file  检查file是否存在并属当前用户所有</span><br><span class="line">-G file  检查file是否存在并且默认组与当前用户相同</span><br><span class="line">file1 -nt file2  检查file1是否比file2新</span><br><span class="line">file1 -ot file2  检查file1是否比file2旧</span><br></pre></td></tr></table></figure>
<h4 id="1-检查目录"><a href="#1-检查目录" class="headerlink" title="1.检查目录"></a>1.检查目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat test11.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># Look before you leap</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">jump_directory=/home/arthur</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$jump_directory</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"The <span class="variable">$jump_directory</span> directory exists"</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$jump_directory</span></span><br><span class="line">  ls</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"The <span class="variable">$jump_directory</span> directory does not exist"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># $</span></span><br><span class="line">$ ./test11.sh</span><br><span class="line">The /home/arthur directory does not exist</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h2><p>if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition1 ] &amp;&amp; [ condition2 ]</span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat test22.sh </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$HOME</span> ] &amp;&amp; [ -w <span class="variable">$HOME</span>/testing ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The file exists and you can write to it"</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"I cannot write to the file"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="if-then-的高级特性"><a href="#if-then-的高级特性" class="headerlink" title="if-then 的高级特性"></a>if-then 的高级特性</h2><p>bash shell提供了两项可在 if-then 语句中使用的高级特性：</p>
<blockquote>
<p>用于数学表达式的双括号</p>
</blockquote>
<blockquote>
<p> 用于高级字符串处理功能的双方括号</p>
</blockquote>
<h3 id="使用双括号"><a href="#使用双括号" class="headerlink" title="使用双括号"></a>使用双括号</h3><p>双括号命令允许你在比较过程中使用高级数学表达式。 test 命令只能在比较中使用简单的<br>算术操作,双括号命令的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>
<p>双括号命令符号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val++  后增</span><br><span class="line">val--  后减</span><br><span class="line">++val  先增</span><br><span class="line">--val  先减</span><br><span class="line">!      逻辑求反</span><br><span class="line">~      位求反</span><br><span class="line">**     幂运算</span><br><span class="line">&lt;&lt;     左位移</span><br><span class="line">&gt;&gt;     右位移</span><br><span class="line">&amp;      位布尔和</span><br><span class="line">|      位布尔或</span><br><span class="line">&amp;&amp;     逻辑和</span><br><span class="line">||     逻辑或</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test23.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># using double parenthesis</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">val1=10</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$val1</span> ** 2 &gt; 90 )) <span class="comment"># 不需要将双括号中表达式里的大于号转义</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  (( val2 = <span class="variable">$val1</span> ** 2 ))</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"The square of <span class="variable">$val1</span> is <span class="variable">$val2</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">$ </span><br><span class="line">$ ./test23.sh</span><br><span class="line">The square of 10 is 100</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="使用双方括号"><a href="#使用双方括号" class="headerlink" title="使用双方括号"></a>使用双方括号</h3><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>
<p>双方括号里的 expression 使用了 test 命令中采用的标准字符串比较。但它提供了 test 命令未提供的另一个特性——模式匹配（pattern matching）。</p>
<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat test24.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># using pattern matching</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$USER</span> == r* ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$USER</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Sorry, I do not know you"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">$ </span><br><span class="line">$ ./test24.sh</span><br><span class="line">Hello rich</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2 id="case-命令"><a href="#case-命令" class="headerlink" title="case 命令"></a>case 命令</h2><p>case 命令会采用列表格式来检查单个变量的多个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">pattern1 | pattern2) commands1;;</span><br><span class="line">pattern3) commands2;;</span><br><span class="line">*) default commands;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat test26.sh</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># using the case command</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$USER</span> <span class="keyword">in</span></span><br><span class="line">rich | barbara)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Welcome, <span class="variable">$USER</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Please enjoy your visit"</span>;;</span><br><span class="line">testing)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Special testing account"</span>;;</span><br><span class="line">jessica)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Do not forget to log off when you're done"</span>;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Sorry, you are not allowed here"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line">$ </span><br><span class="line">$ ./test26.sh</span><br><span class="line">Welcome, rich</span><br><span class="line">Please enjoy your visit</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="for-命令"><a href="#for-命令" class="headerlink" title="for 命令"></a>for 命令</h2><p>bash shell提供了 for 命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash shell中 for 命令的基本格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">---------------------------</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="读取列表中的值"><a href="#读取列表中的值" class="headerlink" title="读取列表中的值"></a>读取列表中的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test1</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># basic for command</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Alabama Alaska </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> The next state is <span class="variable">$test</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ ./test1</span><br><span class="line">The next state is Alabama</span><br><span class="line">The next state is Alaska</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="读取列表中的复杂值"><a href="#读取列表中的复杂值" class="headerlink" title="读取列表中的复杂值"></a>读取列表中的复杂值</h3><p>使用转义字符（反斜线）来将单引号转义；<br>使用双引号来定义用到单引号的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test2</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># another example of how not to use the for command</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don\<span class="string">'t know if "this'</span>ll<span class="string">" work</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">   echo "</span>word:<span class="variable">$test</span><span class="string">"</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">$ ./test2</span></span><br><span class="line"><span class="string">word:I</span></span><br><span class="line"><span class="string">word:don't</span></span><br><span class="line"><span class="string">word:know</span></span><br><span class="line"><span class="string">word:if</span></span><br><span class="line"><span class="string">word:this'll</span></span><br><span class="line"><span class="string">word:work</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>
<p>for 命令用<code>空格</code>来划分列表中的每个值。如果在单独的数据值中有空格，就必须用双引号将这些值圈起来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test3</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># an example of how to properly define values</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Nevada <span class="string">"New Hampshire"</span> <span class="string">"New Mexico"</span> <span class="string">"New York"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Now going to <span class="variable">$test</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ ./test3</span><br><span class="line">Now going to Nevada</span><br><span class="line">Now going to New Hampshire</span><br><span class="line">Now going to New Mexico</span><br><span class="line">Now going to New York</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h3 id="从变量读取列表"><a href="#从变量读取列表" class="headerlink" title="从变量读取列表"></a>从变量读取列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat test4</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># using a variable to hold the list</span></span><br><span class="line">list=<span class="string">"Alabama Alaska Arizona"</span></span><br><span class="line">list=<span class="variable">$list</span><span class="string">" Connecticut"</span> <span class="comment"># 添加文本</span></span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> <span class="variable">$list</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Have you ever visited <span class="variable">$state</span>?"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ ./test4</span><br><span class="line">Have you ever visited Alabama?</span><br><span class="line">Have you ever visited Alaska?</span><br><span class="line">Have you ever visited Arizona?</span><br><span class="line">Have you ever visited Connecticut?</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>添加/拼接文本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>=<span class="string">'hello'</span></span><br><span class="line"><span class="variable">$var</span>=<span class="variable">$var</span><span class="string">" world!"</span></span><br></pre></td></tr></table></figure>
<h3 id="更改字段分隔符"><a href="#更改字段分隔符" class="headerlink" title="更改字段分隔符"></a>更改字段分隔符</h3><p>IFS(internal field separator,内部字段分隔符) 环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">空格</span><br><span class="line">制表符</span><br><span class="line">换行符</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test5b</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># reading values from a file</span></span><br><span class="line">file=<span class="string">"states"</span></span><br><span class="line"><span class="comment"># 可以在shell脚本中临时更改 IFS 环境变量的值来限制被bash shell当作字段分隔符的字符</span></span><br><span class="line"><span class="comment">#告诉bash shell在数据值中忽略空格和制表符</span></span><br><span class="line">IFS=$<span class="string">'\n'</span></span><br><span class="line"> <span class="comment"># 命令替换$() 来执行任何能产生输出的命令，然后在 for 命令中使用该命令的输出</span></span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> $(cat <span class="variable">$file</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Visit beautiful <span class="variable">$state</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ ./test5b</span><br><span class="line">Visit beautiful Alabama</span><br><span class="line">Visit beautiful North Carolina</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还原IFS方法</span></span><br><span class="line"> 在处理代码量较大的脚本时，可能在一个地方需要修改 IFS 的值，然后忽略这次修改，在脚本的其他地方继续沿用 IFS 的默认值。一个可参考的安全实践是在改变 IFS 之前保存原来的 IFS 值，之后再恢复它。 </span><br><span class="line">这种技术可以这样实现： </span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">'\n'</span> </span><br><span class="line">&lt;在代码中使用新的IFS值&gt; </span><br><span class="line">IFS=<span class="variable">$IFS</span>.OLD </span><br><span class="line">这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</span><br></pre></td></tr></table></figure>
<p>还有其他一些 IFS 环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在/etc/passwd文件中）。你要做的就是将 IFS 的值设为冒号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=:</span><br></pre></td></tr></table></figure>
<p>如果要指定多个 IFS 字符，只要将它们在赋值行串起来就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=$<span class="string">'\n'</span>:;<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用 IFS 字符解析数据没有任何限制</p>
<h3 id="用通配符读取目录"><a href="#用通配符读取目录" class="headerlink" title="用通配符读取目录"></a>用通配符读取目录</h3><p>可以用 for 命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat test6</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># iterate through all the files in a directory</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/<span class="built_in">test</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ] <span class="comment">#路径可能包含空格，使用双引号括起来</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a directory"</span></span><br><span class="line">    <span class="keyword">elif</span> [ -f <span class="string">"<span class="variable">$file</span>"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a file"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$ ./test6</span><br><span class="line">/home/rich/<span class="built_in">test</span>/dir1 is a directory</span><br><span class="line">/home/rich/<span class="built_in">test</span>/myprog.c is a file</span><br><span class="line">/home/rich/<span class="built_in">test</span>/myprog is a file</span><br></pre></td></tr></table></figure>
<h2 id="C-语言风格的-for-命令"><a href="#C-语言风格的-for-命令" class="headerlink" title="C 语言风格的 for 命令"></a>C 语言风格的 for 命令</h2><p>bash中C语言风格的 for 循环的基本格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat test8</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># testing the C-style for loop</span></span><br><span class="line"><span class="keyword">for</span> (( i=1; i &lt;= 10; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The next number is <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>使用多个变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># multiple variables</span></span><br><span class="line"><span class="keyword">for</span> (( a=1, b=10; a &lt;= 10; a++, b-- ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> - <span class="variable">$b</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h2 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h2><p>while 命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码 0 。它会在每次迭代的一开始测试 test 命令。在 test 命令返回非零退出状态码时， while 命令会停止执行那组命令。while 命令的格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  other  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test10</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># while command test</span></span><br><span class="line">var1=10</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$var1</span> -gt 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">  var1=$[ <span class="variable">$var1</span> - 1 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while 命令允许你在 while 语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环</p>
<h2 id="until-命令"><a href="#until-命令" class="headerlink" title="until 命令"></a>until 命令</h2><p>until 命令和 while 命令工作的方式完全相反。until 命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为 0 ，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码 0 ，循环就结束了。until 命令的格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until <span class="built_in">test</span> commands</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  other commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test12</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># using the until command</span></span><br><span class="line">var1=100</span><br><span class="line">until [ <span class="variable">$var1</span> -eq 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">  var1=$[ <span class="variable">$var1</span> - 25 ]</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="循环处理文件数据"><a href="#循环处理文件数据" class="headerlink" title="循环处理文件数据"></a>循环处理文件数据</h2><p>通常必须遍历存储在文件中的数据。这要求结合已经讲过的两种技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用嵌套循环</span><br><span class="line">修改 IFS 环境变量</span><br></pre></td></tr></table></figure>
<p>这个脚本使用了两个不同的 IFS 值来解析数据。第一个 IFS 值解析出<code>/etc/passwd</code>文件中的单独的行。内部 for 循环接着将 IFS 的值修改为冒号，允许你从<code>/etc/passwd</code>的行中解析出单独的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># changing the IFS value</span></span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span></span><br><span class="line">IFS=$<span class="string">'\n'</span></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> $(cat /etc/passwd)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Values in <span class="variable">$entry</span> –"</span></span><br><span class="line">    IFS=:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$entry</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$value</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h2><p>有两个命令能帮我们控制循环内部的情况,<code>break</code>命令和<code>continue</code>命令。</p>
<h3 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h3><p>用 break 命令来退出任意类型的循环，包括while 和 until 循环。</p>
<p>有时你在内部循环，但需要停止外部循环。 break 命令接受单个命令行参数值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> n</span><br></pre></td></tr></table></figure>
<p>其中 n 指定了要跳出的循环层级。默认情况下， n 为 1 ，表明跳出的是当前的循环。如果你将n 设为 2 ， break 命令就会停止下一级的外部循环。</p>
<h3 id="continue-命令"><a href="#continue-命令" class="headerlink" title="continue 命令"></a>continue 命令</h3><p>continue 命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。</p>
<p>continue 命令也允许通过命令行参数指定要继续执行哪一级循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">continue</span> n</span><br></pre></td></tr></table></figure>
<p>其中 n 定义了要继续的循环层级。</p>
<h2 id="处理循环的输出"><a href="#处理循环的输出" class="headerlink" title="处理循环的输出"></a>处理循环的输出</h2><p>在shell脚本中，你可以对循环的输出使用管道或进行重定向,可以通过在 done 命令之后添加一个处理命令来实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$file</span>"</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a directory"</span></span><br><span class="line">  <span class="keyword">elif</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is a file"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &gt; output.txt</span><br><span class="line"><span class="comment"># shell会将 for 命令的结果重定向到文件output.txt中，而不是显示在屏幕上</span></span><br><span class="line"><span class="comment"># 这种方法同样适用于将循环的结果管接给另一个命令</span></span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> <span class="string">"North Dakota"</span> Connecticut Illinois Alabama Tennessee </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$state</span> is the next place to go"</span> </span><br><span class="line"><span class="keyword">done</span> | sort </span><br><span class="line"><span class="comment"># 。 for 命令的输出传给了 sort 命令，该命令会改变 for 命令输出结果的顺序</span></span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="查找可执行文件"><a href="#查找可执行文件" class="headerlink" title="查找可执行文件"></a>查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat test25</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># finding files in the PATH</span></span><br><span class="line">IFS=:</span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> <span class="variable">$PATH</span> <span class="comment"># 对环境变量 PATH 中的目录进行迭代</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$folder</span>:"</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$folder</span>/* <span class="comment"># 迭代特定目录中的所有文件</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -x <span class="variable">$file</span> ] <span class="comment"># 检查各个文件是否具有可执行权限</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"  <span class="variable">$file</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="创建多个用户账户"><a href="#创建多个用户账户" class="headerlink" title="创建多个用户账户"></a>创建多个用户账户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test26</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># process new user accounts</span></span><br><span class="line">input=<span class="string">"users.csv"</span></span><br><span class="line"><span class="keyword">while</span> IFS=<span class="string">','</span> <span class="built_in">read</span> -r userid name</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"adding <span class="variable">$userid</span>"</span></span><br><span class="line">  useradd -c <span class="string">"<span class="variable">$name</span>"</span> -m <span class="variable">$userid</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$input</span>"</span></span><br><span class="line">$</span><br><span class="line"><span class="variable">$input</span> 变量指向数据文件，并且该变量被作为 <span class="keyword">while</span> 命令的重定向数据。</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/20/shell-script-2-structed-command/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-19 </div>
			<div class="article-title"><a href="/2018/02/19/shell-script-1-basic-script/" >shell学习(1)构建基本脚本</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="使用多个命令"><a href="#使用多个命令" class="headerlink" title="使用多个命令"></a>使用多个命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用分号分隔多个命令</span></span><br><span class="line">$ date ; who</span><br></pre></td></tr></table></figure>
<h2 id="基本shell脚本文件"><a href="#基本shell脚本文件" class="headerlink" title="基本shell脚本文件"></a>基本shell脚本文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># This script displays the date and who's logged on</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"The time and date are: "</span> <span class="comment">#把文本字符串和命令输出显示在同一行</span></span><br><span class="line">date</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Let's see who's logged into the system:"</span></span><br><span class="line">who</span><br><span class="line">$</span><br><span class="line"><span class="comment"># 运行脚本文件</span></span><br><span class="line">$ test1 </span><br><span class="line">bash: test1: <span class="built_in">command</span> not found </span><br><span class="line">PATH 环境变量中没有找到命令，需要通过一下两种方式运行脚本:</span><br><span class="line">1.将shell脚本文件所处的目录添加到 PATH 环境变量中； </span><br><span class="line">2.在提示符中用绝对或相对文件路径来引用shell脚本文件。</span><br><span class="line">$ ./test1</span><br></pre></td></tr></table></figure>
<h2 id="显示消息"><a href="#显示消息" class="headerlink" title="显示消息"></a>显示消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Hello World</span><br><span class="line"><span class="comment"># 默认情况不需要引号，单双引号混用时才需要引号</span></span><br><span class="line">-n 不换行</span><br></pre></td></tr></table></figure>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID（也称为UID）、用户的默认主目录以及shell查找程序的搜索路径。通过set命令查看当前环境变量列表。</p>
<p>在环境变量名称之前加上美元符($) 来使用这些环境变量,并且可以再双引号中使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"User info for userid: <span class="variable">$USER</span>"</span></span><br><span class="line"><span class="built_in">echo</span> UID: <span class="variable">$UID</span></span><br><span class="line"><span class="built_in">echo</span> HOME: <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;variable&#125;</span> <span class="comment">#变量名两侧额外的花括号通常用来帮助识别美元符后的变量名</span></span><br></pre></td></tr></table></figure>
<p>反斜线允许shell脚本将美元符解读为实际的美元符，而不是变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"The cost of the item is \$15"</span></span><br><span class="line">The cost of the item is <span class="variable">$15</span></span><br></pre></td></tr></table></figure>
<h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>shell脚本还允许在脚本中定义和使用自己的变量，用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个，区分大小写。</p>
<p>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</p>
<p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">value1=10</span><br><span class="line">value2=<span class="variable">$value1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$value2</span></span><br><span class="line">--------</span><br><span class="line">The resulting value is 10</span><br><span class="line">--------</span><br><span class="line">value2=value1</span><br><span class="line">--------</span><br><span class="line">The resulting value is value1</span><br><span class="line"><span class="comment"># 没有美元符，shell会将变量名解释成普通的文本字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。</p>
<p>有两种方法可以将命令输出赋给变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反引号字符(`)</span><br><span class="line">$() 格式</span><br></pre></td></tr></table></figure>
<p>命令替换允许你将shell命令的输出赋给变量，注意，赋值等号和命令替换字符之间没有空格</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testing=`date`</span><br><span class="line">testing=$(date)</span><br><span class="line"></span><br><span class="line">$ cat test5 </span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">testing=$(date) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The date and time are: "</span> <span class="variable">$testing</span> </span><br><span class="line">$ </span><br><span class="line">$ chmod u+x test5 </span><br><span class="line">$ ./test5 </span><br><span class="line">The date and time are:  Mon Jan 31 20:23:25 EDT 2014 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p> 命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的。<br>  在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。</p>
<h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>最基本的重定向将命令的输出发送到一个文件中。bash shell用大于号(&gt;)来输出重定向,</p>
<p>双大于号（&gt;&gt;）来追加数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; outputfile</span><br><span class="line"><span class="built_in">command</span> &gt;&gt; outputfile <span class="comment">#追加数据</span></span><br></pre></td></tr></table></figure>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>输入重定向将文件的内容重定向到命令,输入重定向符号是小于号（&lt;）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt; inputfile</span><br></pre></td></tr></table></figure>
<p>记忆：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt; test6</span><br><span class="line">      2      11      60</span><br><span class="line">  -------------------------------------------------   </span><br><span class="line">wc 命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：</span><br><span class="line">文本的行数</span><br><span class="line">文本的词数</span><br><span class="line">文本的字节数</span><br></pre></td></tr></table></figure></p>
<p>另外一种输入重定向的方法，称为内联输入重定向（inline input redirection）。这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了</p>
<p>内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt; marker</span><br><span class="line">data</span><br><span class="line">marker</span><br></pre></td></tr></table></figure>
<p>在命令行上使用内联输入重定向时，shell会用 PS2 环境变量中定义的次提示符来提示输入数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wc &lt;&lt; EOF</span><br><span class="line">&gt; <span class="built_in">test</span> string 1</span><br><span class="line">&gt; <span class="built_in">test</span> string 2</span><br><span class="line">&gt; <span class="built_in">test</span> string 3</span><br><span class="line">&gt; EOF</span><br><span class="line">      3       9      42 </span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串。</span></span><br><span class="line"><span class="comment"># wc 命令会对内联输入重定向提供的数据进行行、词和字节计数。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>将一个命令的输出作为另一个命令的输入,这个过程叫作管道连接（piping）,管道被放在命令之间，将一个命令的输出重定向到另一个命令中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>
<p>可以利用管道将 rpm 命令的输出送入 sort 命令来产生结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | sort</span><br><span class="line">abrt-1.1.14-1.fc14.i686 </span><br><span class="line">abrt-addon-ccpp-1.1.14-1.fc14.i686 </span><br><span class="line">$ rpm -qa | sort &gt; rpm.list</span><br><span class="line"><span class="comment"># 可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。 </span></span><br><span class="line">$ rpm -qa | sort | more</span><br></pre></td></tr></table></figure>
<h2 id="执行数学运算"><a href="#执行数学运算" class="headerlink" title="执行数学运算"></a>执行数学运算</h2><h3 id="expr-命令（复杂）"><a href="#expr-命令（复杂）" class="headerlink" title="expr 命令（复杂）"></a>expr 命令（复杂）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1 + 5</span><br><span class="line">6</span><br><span class="line">$ expr 5 \* 2</span><br><span class="line">10</span><br><span class="line"> </span><br><span class="line">var1=10</span><br><span class="line">var2=20</span><br><span class="line">var3=$(expr <span class="variable">$var2</span> / <span class="variable">$var1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用方括号"><a href="#使用方括号" class="headerlink" title="使用方括号"></a>使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号<code>$[ operation ]</code>将数学表达式围起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ var1=$[1 + 5]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">6</span><br><span class="line">$ var2=$[<span class="variable">$var1</span> * 2]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var2</span></span><br><span class="line">12</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>bash shell数学运算符只支持整数运算。需要使用bc命令计算， z shell（zsh）提供了完整的浮点数算术操作。</p>
<h2 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h2><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。</p>
<h3 id="查看退出状态码"><a href="#查看退出状态码" class="headerlink" title="查看退出状态码"></a>查看退出状态码</h3><p>Linux提供了一个专门的变量 $? 来保存上个已执行命令的退出状态码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Sat Jan 15 10:01:30 EDT 2014</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>按照惯例，一个成功结束的命令的退出状态码是 0 。如果一个命令结束时有错误，退出状态码就是一个正数值。</p>
<p>Linux退出状态码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0  命令成功结束 </span><br><span class="line">1  一般性未知错误 </span><br><span class="line">2  不适合的shell命令 </span><br><span class="line">126  命令不可执行 </span><br><span class="line">127  没找到命令 </span><br><span class="line">128  无效的退出参数 </span><br><span class="line">128+x  与Linux信号x相关的严重错误 </span><br><span class="line">130  通过Ctrl+C终止的命令 </span><br><span class="line">255  正常范围之外的退出状态码</span><br></pre></td></tr></table></figure>
<h3 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h3><p>默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出,exit 命令允许你在脚本结束时指定一个退出状态码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test13</span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># testing the exit status</span></span><br><span class="line">var1=10</span><br><span class="line">var2=30</span><br><span class="line">var3=$[<span class="variable">$var1</span> + <span class="variable">$var2</span>]</span><br><span class="line"><span class="built_in">echo</span> The answer is <span class="variable">$var3</span></span><br><span class="line"><span class="built_in">exit</span> 5</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>也可以在 exit 命令的参数中使用变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> <span class="variable">$var3</span></span><br></pre></td></tr></table></figure>
<p>退出状态码超过255时。shell通过模运算计算退出码,最终的结果是指定的数值除以256后得到的余数</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/19/shell-script-1-basic-script/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-18 </div>
			<div class="article-title"><a href="/2018/02/18/linux-cmd-5-vim-editor/" >Linux命令行(5)vim编辑器</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>vi编辑器是Unix系统最初的编辑器。它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本<br>在GNU项目将vi编辑器移植到开源世界时，他们决定对其作一些改进。由于它不再是以前Unix中的那个原始的vi编辑器了，开发人员也就将它重命名为vi improved，或vim</p>
<h2 id="检查-vim-软件包"><a href="#检查-vim-软件包" class="headerlink" title="检查 vim 软件包"></a>检查 vim 软件包</h2><p>在有些发行版中安装的是完整的vim，另外还有一个 vi 命令的别名，</p>
<p>就像下面所显示的CentOS发行版中的那样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> vi</span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br><span class="line">$</span><br><span class="line">$ ls -l /usr/bin/vim</span><br><span class="line">-rwxr-xr-x. 1 root root 1967072 Apr  5  2012 /usr/bin/vim</span><br></pre></td></tr></table></figure>
<p>要注意的是，在Ubuntu发行版中不仅没有 vi 命令的别名，而且 /usr/bin/vi 程序属于一系列文件链接中的一环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> vi</span><br><span class="line">-bash: <span class="built_in">alias</span>: vi: not found</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">which</span> vi</span><br><span class="line">/usr/bin/vi</span><br><span class="line">$</span><br><span class="line">$ ls -l /usr/bin/vi</span><br><span class="line">lrwxrwxrwx 1 root root 20 Apr 22 12:39 </span><br><span class="line">/usr/bin/vi -&gt; /etc/alternatives/vi</span><br><span class="line">$</span><br><span class="line">$ ls -l /etc/alternatives/vi</span><br><span class="line">lrwxrwxrwx 1 root root 17 Apr 22 12:33 </span><br><span class="line">/etc/alternatives/vi -&gt; /usr/bin/vim.tiny</span><br><span class="line">$</span><br><span class="line">$ ls -l /usr/bin/vim.tiny</span><br><span class="line">-rwxr-xr-x 1 root root 884360 Jan  2 14:40 </span><br><span class="line">/usr/bin/vim.tiny</span><br><span class="line">$</span><br><span class="line">$ readlink -f /usr/bin/vi</span><br><span class="line">/usr/bin/vim.tiny</span><br></pre></td></tr></table></figure>
<p>当输入 vi 命令时，执行的是程序 /usr/bin/vim.tiny 。 vim.tiny 只提供少量的vim编辑器功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装完整版的vim</span></span><br><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<h2 id="vim-基础"><a href="#vim-基础" class="headerlink" title="vim 基础"></a>vim 基础</h2><p>vim编辑器在内存缓冲区中处理数据。通过vim/vi命令启动vim编辑器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.c</span><br></pre></td></tr></table></figure></p>
<p>vim编辑器有两种操作模式： </p>
<blockquote>
<p> 普通模式(默认模式)</p>
</blockquote>
<blockquote>
<p> 插入模式 (<code>i</code>键切换，<code>esc</code>键退出)</p>
</blockquote>
<p>vim中有用来移动光标的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h ：左移一个字符。</span><br><span class="line">j ：下移一行（文本中的下一行）</span><br><span class="line">k ：上移一行（文本中的上一行）</span><br><span class="line">l ：右移一个字符</span><br></pre></td></tr></table></figure>
<p>在大的文本文件中提高移动速度的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageDown （或Ctrl+F）：下翻一屏。</span><br><span class="line">PageUp （或Ctrl+B）：上翻一屏。</span><br><span class="line">G ：移到缓冲区的最后一行。</span><br><span class="line">num G ：移动到缓冲区中的第 num 行。</span><br><span class="line">gg ：移到缓冲区的第一行。</span><br></pre></td></tr></table></figure>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>vim编辑器在普通模式下有个特别的功能叫命令行模式。命令行模式提供了一个交互式命令行，可以输入额外的命令来控制vim的行为在普通模式下按下冒号键进入命令行模式。光标会移动到消息行，然后出现冒号，等待输入命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q ：如果未修改缓冲区数据，退出。</span><br><span class="line">q! ：取消所有对缓冲区数据的修改并退出。</span><br><span class="line">w filename ：将文件保存到另一个文件中。</span><br><span class="line">wq ：将缓冲区数据保存到文件中并退出。</span><br></pre></td></tr></table></figure>
<h3 id="编辑数据"><a href="#编辑数据" class="headerlink" title="编辑数据"></a>编辑数据</h3><p>在普通模式下，vim编辑器提供了一些命令来编辑缓冲区中的数据。 在普通模式下。vim编辑器通常会将删除键（Delete键）识别成 x 命令的功能，删除当前光标所在位置的字符。vim编辑器在普通模式下通常不识别退格键（Backspace键）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x  删除当前光标所在位置的字符 </span><br><span class="line">dd  删除当前光标所在行 </span><br><span class="line">dw  删除当前光标所在位置的单词 </span><br><span class="line">d$  删除当前光标所在位置至行尾的内容 </span><br><span class="line">J  删除当前光标所在行行尾的换行符（拼接行） </span><br><span class="line">u  撤销前一编辑命令 </span><br><span class="line">a  在当前光标后追加数据 </span><br><span class="line">A  在当前光标所在行行尾追加数据 </span><br><span class="line">r char  用char替换当前光标所在位置的单个字符 </span><br><span class="line">R text  用text覆盖当前光标所在位置的数据，直到按下ESC键</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">2x 会删除从光标当前位置开始的两个字符</span><br><span class="line">5dd 会删除从光标当前所在行开始的5行</span><br></pre></td></tr></table></figure>
<h3 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 剪切(vim在删除数据时，实际上会将数据保存在单独的一个寄存器中)</span></span><br><span class="line">dd</span><br><span class="line"><span class="comment"># 复制y(yank)</span></span><br><span class="line">y</span><br><span class="line"><span class="comment"># 复制一个单词</span></span><br><span class="line">yw</span><br><span class="line"><span class="comment"># 复制到行尾</span></span><br><span class="line">y$</span><br><span class="line"><span class="comment"># 粘贴(将文本插入到当前光标所在行之后)</span></span><br><span class="line">p</span><br></pre></td></tr></table></figure>
<h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>复制时你无法确定到底复制了什么东西，直到将它粘贴到其他地方才能明白，vim提供了可视模式(v键进入)。</p>
<p>可视模式会在你移动光标时高亮显示文本。可以用可视模式选取要复制的文本。要进入可视模式，应移动光标到要开始复制的位置，通过v键进入。你会注意到光标所在位置的文本已经被高亮显示了。下一步，移动光标来覆盖你想要复制的文本。在移动光标时，vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。现在寄存器中已经有了要复制的文本，移动光标到你要放置的位置，使用 p 命令来粘贴。</p>
<h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><p>要输入一个查找字符串，就按下斜线（/）键。光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。vim编辑器会采用以下三种回应中的一种。</p>
<blockquote>
<p>如果要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。</p>
</blockquote>
<blockquote>
<p>如果要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。</p>
</blockquote>
<blockquote>
<p>输出一条错误消息，说明在文件中没有找到要查找的文本。</p>
</blockquote>
<p>要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（next）。</p>
<p>替换命令允许你快速用另一个单词来替换文本中的某个单词。必须进入命令行模式才能使用替换命令。替换命令的格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new/</span><br></pre></td></tr></table></figure>
<p>vim编辑器会跳到 old 第一次出现的地方，并用 new 来替换。可以对替换命令作一些修改来替换多处文本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new/g ：一行命令替换所有old</span><br><span class="line">:n,ms/old/new/g ：替换行号 n 和 m 之间所有old</span><br><span class="line">:%s/old/new/g ：替换整个文件中的所有old</span><br><span class="line">:%s/old/new/gc ：替换整个文件中的所有 old ，但在每次出现时提示</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/18/linux-cmd-5-vim-editor/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-17 </div>
			<div class="article-title"><a href="/2018/02/17/linux-cmd-4-linux-pms/" >Linux命令行(4)软件包管理系统(PMS)</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="包管理基础"><a href="#包管理基础" class="headerlink" title="包管理基础"></a>包管理基础</h2><p>各种主流Linux发行版都采用了某种形式的包管理系统(package management system,PMS)来控制软件和库的安装。PMS利用一个数据库来记录各种相关内容：<br>Linux系统上已安装了什么软件包；<br>每个包安装了什么文件；<br>每个已安装软件包的版本。</p>
<p>软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库（repository）。可以用PMS工具来搜索新的软件包，或者是更新系统上已安装软件包。 </p>
<p>软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。PMS工具将会检测这些依赖关系，并在安装需要的包之前先安装好所有额外的软件包。</p>
<p>PMS的不足之处在于目前还没有统一的标准工具。PMS工具及相关命令在不同的Linux发行版上有很大的不同。Linux中广泛使用的两种主要的PMS基础工具是dpkg和rpm。</p>
<p>基于Debian的发行版（如Ubuntu和Linux Mint）使用的是 dpkg 命令，这些发行版的PMS工具也是以该命令为基础的。 dpkg 会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包。</p>
<p>基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是 rpm 命令，该命令是其PMS的底层基础。类似于 dpkg 命令， rmp 命令能够列出已安装包、安装新包和删除已有软件。</p>
<h2 id="基于-Debian-的系统"><a href="#基于-Debian-的系统" class="headerlink" title="基于 Debian 的系统"></a>基于 Debian 的系统</h2><p><code>dpkg</code> 命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get</span><br><span class="line">apt-cache</span><br><span class="line">aptitude</span><br></pre></td></tr></table></figure>
<p>到目前为止，最常用的命令行工具是aptitude,<code>aptitude</code>工具本质上是<code>apt</code>工具和 <code>dpkg</code> 的前端。 <code>dpkg</code>是软件包管理系统工具，而aptitude则是完整的软件包管理系统。<br>命令行下使用 <code>aptitude</code> 命令有助于避免常见的软件安装问题，如软件依赖关系缺失、系统环境不稳定及其他一些不必要的麻烦。本节将会介绍如何在命令行下使用 <code>aptitude</code>命令工具。</p>
<h3 id="用-aptitude-管理软件包"><a href="#用-aptitude-管理软件包" class="headerlink" title="用 aptitude 管理软件包"></a>用 aptitude 管理软件包</h3><p>aptitude 命令直接进入软件包管理,q退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aptitude show package_name</span><br><span class="line">------------------------------</span><br><span class="line">ptitude show mysql-client</span><br><span class="line">Package: mysql-client             </span><br><span class="line">State: not installed</span><br><span class="line">Version: 5.5.38-0ubuntu0.14.04.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>无法通过 aptitude 看到的一个细节是所有跟某个特定软件包相关的所有文件的列表。要得到这个列表，就必须用 dpkg 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L package_name</span><br><span class="line">------------------------------</span><br><span class="line">$ dpkg -L vim-common</span><br><span class="line">/.</span><br><span class="line">/usr/lib/mime/packages</span><br><span class="line">/usr/lib/mime/packages/vim-common</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>同样可以进行反向操作，查找某个特定文件属于哪个软件包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dpkg --search absolute_file_name</span><br><span class="line">-------------------------------------</span><br><span class="line">$ dpkg --search /usr/bin/xxd</span><br><span class="line">vim-common: /usr/bin/xxd</span><br></pre></td></tr></table></figure>
<h3 id="用-aptitude-安装软件包"><a href="#用-aptitude-安装软件包" class="headerlink" title="用 aptitude 安装软件包"></a>用 aptitude 安装软件包</h3><h4 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aptitude search package_name</span><br><span class="line">--------------------------------------</span><br><span class="line">$ aptitude search wine</span><br><span class="line">p  gnome-wine-icon-theme          - red variation of the GNOME- ...</span><br><span class="line">v  libkwineffects1-api            - </span><br><span class="line">p  libkwineffects1a                - library used by effects...</span><br><span class="line">p  q4wine                          - Qt4 GUI <span class="keyword">for</span> wine (W.I.N.E)</span><br></pre></td></tr></table></figure>
<p>在每个包名字之前都有一个 p 或 i 。如果看到一个 i ，说明这个包现在已经安装到了你的系统上了。如果看到一个 p 或 v ，说明这个包可用，但还没安装</p>
<h4 id="从软件仓库中安装软件包。"><a href="#从软件仓库中安装软件包。" class="headerlink" title="从软件仓库中安装软件包。"></a>从软件仓库中安装软件包。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aptitude install package_name</span><br><span class="line">-----------------------------</span><br><span class="line">sudo aptitude install wine</span><br></pre></td></tr></table></figure>
<p>要检查安装过程是否正常，只要再次使用 search 选项就可以了。软件包出现了 i u  ，这说明它已经安装好了。</p>
<h4 id="用-aptitude-更新软件"><a href="#用-aptitude-更新软件" class="headerlink" title="用 aptitude 更新软件"></a>用 aptitude 更新软件</h4><p>尽管 aptitude 可以帮忙解决安装软件时遇到的问题，但解决有依赖关系的多个包的更新会比较烦琐。要用软件仓库中的新版本妥善地更新系统上所有的软件包，可用 safe-upgrade 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude safe-upgrade</span><br></pre></td></tr></table></figure>
<p>还有一些不那么保守的软件升级选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aptitude full-upgrade</span><br><span class="line">aptitude dist-upgrade</span><br></pre></td></tr></table></figure>
<p>这些选项执行相同的任务，将所有软件包升级到最新版本。它们同 safe-upgrade 的区别在于，它们不会检查包与包之间的依赖关系。整个包依赖关系问题非常麻烦。如果不是很确定各种包的依赖关系，那还是坚持用 safe-upgrade 选项吧</p>
<h4 id="用-aptitude-卸载软件"><a href="#用-aptitude-卸载软件" class="headerlink" title="用 aptitude 卸载软件"></a>用 aptitude 卸载软件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要想只删除软件包而不删除数据和配置文件</span></span><br><span class="line">aptitude remove</span><br><span class="line"></span><br><span class="line"><span class="comment">#要删除软件包和相关的数据和配置文件</span></span><br><span class="line">aptitude purge</span><br><span class="line">---------------------------------------------------</span><br><span class="line">sudo aptitude purge wine</span><br></pre></td></tr></table></figure>
<p>要看软件包是否已删除，可以再用 aptitude 的 search 选项。如果在软件包名称的前面看到一个 c ，意味着软件已删除，但配置文件尚未从系统中清除；如果前面是个 p 的话，说明配置文件也已删除。</p>
<h4 id="aptitude-仓库"><a href="#aptitude-仓库" class="headerlink" title="aptitude 仓库"></a>aptitude 仓库</h4><p>aptitude 默认的软件仓库位置是在安装Linux发行版时设置的。具体位置存储在文件<code>/etc/apt/sources.lis</code>t中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/apt/sources.list</span><br><span class="line"><span class="comment">#deb cdrom:[Ubuntu 14.04 LTS _Trusty Tahr_ - Release i386 (20140417)]/</span></span><br><span class="line">trusty main restricted</span><br><span class="line"> </span><br><span class="line"><span class="comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span></span><br><span class="line"><span class="comment"># newer versions of the distribution.</span></span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ trusty main restricted</span><br><span class="line">deb-src http://us.archive.ubuntu.com/ubuntu/ trusty main restricted</span><br><span class="line">---------------------------------------</span><br><span class="line">deb (or deb-src) address  distribution_name  package_type_list</span><br><span class="line">deb 或 deb-src 的值表明了软件包的类型。</span><br><span class="line">deb值说明这是一个已编译程序源</span><br><span class="line">deb-src值则说明这是一个源代码的源</span><br><span class="line">address 条目是软件仓库的Web地址</span><br><span class="line">distribution_name 条目是这个特定软件仓库的发行版版本的名称,在这个例子中，发行版名称是trusty</span><br><span class="line">package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。</span><br><span class="line">你可以看到诸如main、restricted、universe和partner这样的值</span><br></pre></td></tr></table></figure>
<h2 id="基于-Red-Hat-的系统"><a href="#基于-Red-Hat-的系统" class="headerlink" title="基于 Red Hat 的系统"></a>基于 Red Hat 的系统</h2><p>和基于Debian的发行版类似，基于Red  Hat的系统也有几种不同的可用前端工具。常见的有以下3种。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum ：在Red Hat和Fedora中使用。</span><br><span class="line">urpm ：在Mandriva中使用。</span><br><span class="line">zypper ：在openSUSE中使用。</span><br></pre></td></tr></table></figure>
<p>这些前端都是基于 rpm 命令行工具的</p>
<h3 id="列出已安装包"><a href="#列出已安装包" class="headerlink" title="列出已安装包"></a>列出已安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure>
<p>输出的信息可能会在屏幕上一闪而过，所以最好是将已安装包的列表重定向到一个文件中。可以用 more 或 less 命令（或一个GUI编辑器）按照需要查看这个列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed &gt; installed_software</span><br></pre></td></tr></table></figure>
<p>yum 擅长找出某个特定软件包的详细信息。它能给出关于包的非常详尽的描述，另外你还可以通过一条简单的命令查看包是否已安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum list package_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># yum list xterm  </span></span><br><span class="line">Loaded plugins: langpacks, presto, refresh-packagekit  </span><br><span class="line">Adding en_US to language list  </span><br><span class="line">Available Packages  </span><br><span class="line">xterm.i686 253-1.el6  </span><br><span class="line"></span><br><span class="line"><span class="comment"># yum list installed xterm  </span></span><br><span class="line">Loaded plugins: refresh-packagekit </span><br><span class="line">Error: No matching Packages to list  </span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>找出系统上的某个特定文件属于哪个软件包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum provides file_name</span><br></pre></td></tr></table></figure></p>
<h3 id="用-yum-安装软件"><a href="#用-yum-安装软件" class="headerlink" title="用 yum 安装软件"></a>用 yum 安装软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install package_name</span><br></pre></td></tr></table></figure>
<p>也可以手动下载 rpm 安装文件并用 yum 安装，这叫作本地安装。基本的命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall package_name.rpm</span><br></pre></td></tr></table></figure>
<h3 id="用-yum-更新软件"><a href="#用-yum-更新软件" class="headerlink" title="用 yum 更新软件"></a>用 yum 更新软件</h3><p>列出所有已安装包的可用更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list updates</span><br></pre></td></tr></table></figure>
<p>更新某个特定软件包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update package_name</span><br></pre></td></tr></table></figure>
<p>对更新列表中的所有包进行更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>
<h3 id="用-yum-卸载软件"><a href="#用-yum-卸载软件" class="headerlink" title="用 yum 卸载软件"></a>用 yum 卸载软件</h3><p>和 aptitude 一样，你需要决定是否保留软件包的数据和配置文件</p>
<p>只删除软件包而保留配置文件和数据文件,使用remove</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove package_name</span><br></pre></td></tr></table></figure>
<p>要删除软件和它所有的文件,使用erase</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum erase package_name</span><br></pre></td></tr></table></figure>
<h3 id="处理损坏的包依赖关系"><a href="#处理损坏的包依赖关系" class="headerlink" title="处理损坏的包依赖关系"></a>处理损坏的包依赖关系</h3><p>有时在安装多个软件包时，某个包的软件依赖关系可能会被另一个包的安装覆盖掉。这叫作损坏的包依赖关系（broken dependency）如果系统出现了这个问题，先试试下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure>
<p>然后试着用 yum update。有时，只要清理了放错位置的文件就可以了。如果这还解决不了问题，试试下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist package_name</span><br></pre></td></tr></table></figure>
<p>这个命令显示了所有包的库依赖关系以及什么软件可以提供这些库依赖关系,一旦知道某个包需要的库，你就能安装它们了<br>如果这样仍未解决问题，还有最后一招：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update --skip-broken</span><br><span class="line">--skip-broken 选项允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。</span><br></pre></td></tr></table></figure>
<h3 id="yum-软件仓库"><a href="#yum-软件仓库" class="headerlink" title="yum 软件仓库"></a>yum 软件仓库</h3><p>要想知道你现在正从哪些仓库中获取软件，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure>
<p>yum 的仓库定义文件位于<code>/etc/yum.repos.d</code></p>
<h3 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info package_name</span><br></pre></td></tr></table></figure>
<h2 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h2><p>在好用的<code>rpm</code> 和 <code>dpkg</code>工具出现之前，管理员必须知道如何从<code>tarball</code>来解包和安装软件。将文件下载到你的Linux系统上，然后解包。<br>要解包一个软件的<code>tarball</code>，用标准的 tar 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf sysstat-11.1.1.tar.gz</span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">cd</span> sysstat-11.1.1</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure>
<p>在这个目录的列表中，应该能看到README或AAAREADME文件。读这个文件非常重要。该文件中包含了软件安装所需要的操作。<br>按照README文件中的建议，下一步是系统配置。它会检查你的Linux系统，确保它拥有合适的编译器能够编译源代码，另外还要具备正确的库依赖关系</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
<p>如果哪里有错了，在 configure 步骤中会显示一条错误消息说明缺失了什么东西</p>
<p>用 make 命令来构建各种二进制文件<br>make 命令会编译源码，然后链接器会为这个包创建最终的可执行文件。<br>和configure 命令一样,make 命令会在编译和链接所有的源码文件的过程中产生大量的输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>make 步骤结束时，可运行的软件程序就会出现在目录下！但是从那个目录下运行程序有些不便。你会想将它安装到Linux系统中常用的位置上。要这样的话，就必须以root用户身份登录（或者用 sudo 命令，如果你的Linux发行版偏好这个的话），然后用 make 命令的 install 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/17/linux-cmd-4-linux-pms/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-16 </div>
			<div class="article-title"><a href="/2018/02/16/linux-cmd-3-linux-file-permissions/" >Linux命令行(3)理解Linux文件权限</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="Linux-的安全性"><a href="#Linux-的安全性" class="headerlink" title="Linux 的安全性"></a>Linux 的安全性</h2><p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的</p>
<h3 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a><code>/etc/passwd</code>文件</h3><p>Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。为普通用户创建账户时，大多数Linux系统会从500开始，将第一个可用UID分配给这个账户。root用户账户是Linux系统的管理员，固定分配给它的UID是 0。/etc/passwd是一个标准的文本文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">mysql:x:501:501::/home/mysql:/sbin/nologin</span><br><span class="line">-----------------------------------</span><br><span class="line">/etc/passwd文件的字段包含了如下信息</span><br><span class="line">登录用户名</span><br><span class="line">用户密码</span><br><span class="line">用户账户的UID(数字形式)</span><br><span class="line">用户账户的组ID(GID)(数字形式)</span><br><span class="line">用户账户的文本描述(称为备注字段)</span><br><span class="line">用户HOME目录的位置</span><br><span class="line">用户的默认shell</span><br></pre></td></tr></table></figure>
<p><code>/etc/passwd</code>文件中的密码字段都被设置成了x,，绝大多数Linux系统都将用户密码保存在另一个单独的文件中叫作shadow文件，位置在<code>/etc/shadow</code>）。只有特定的程序（比如登录程序）才能访问这个文件。</p>
<h3 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a><code>/etc/shadow</code> 文件</h3><p><code>/etc/shadow</code>文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问<code>/etc/shadow</code>文件，这让它比起<code>/etc/passwd</code>安全许多。<br><code>/etc/shadow</code>文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rich:<span class="variable">$1</span>$.FfcK0ns<span class="variable">$f1UgiyHQ25wrB</span>/hykCn020:11627:0:99999:7:::</span><br><span class="line">-------------------------------------</span><br><span class="line">在/etc/shadow文件的每条记录中都有9个字段：</span><br><span class="line">与/etc/passwd文件中的登录名字段对应的登录名</span><br><span class="line">加密后的密码</span><br><span class="line">自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</span><br><span class="line">多少天后才能更改密码</span><br><span class="line">多少天后必须更改密码</span><br><span class="line">密码过期前提前多少天提醒用户更改密码 </span><br><span class="line">密码过期后多少天禁用用户账户</span><br><span class="line">用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</span><br><span class="line">预留字段给将来使用</span><br></pre></td></tr></table></figure>
<h3 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h3><p>useradd用来向Linux系统添加新用户。</p>
<p><code>useradd</code> 命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在<code>/etc/default/useradd</code>文件中。可以使用<code>useradd -D</code>命令查看所用Linux系统中的这些默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin/useradd -D </span></span><br><span class="line">GROUP=100 </span><br><span class="line">HOME=/home </span><br><span class="line">INACTIVE=-1 </span><br><span class="line">EXPIRE= </span><br><span class="line">SHELL=/bin/bash </span><br><span class="line">SKEL=/etc/skel </span><br><span class="line">CREATE_MAIL_SPOOL=yes </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">新用户会被添加到GID为 100 的公共组；</span><br><span class="line">新用户的HOME目录将会位于/home/loginname；</span><br><span class="line">新用户账户密码在过期后不会被禁用；</span><br><span class="line">新用户账户未被设置过期日期；</span><br><span class="line">新用户账户将bash shell作为默认shell；</span><br><span class="line">系统会将/etc/skel目录下的内容复制到用户的HOME目录下；</span><br><span class="line">系统为该用户账户在mail目录下创建一个用于接收邮件的文件。</span><br><span class="line">$ ls -al /etc/skel</span><br><span class="line">total 32 </span><br><span class="line">drwxr-xr-x   2 root root  4096 2010-04-29 08:26 . </span><br><span class="line">drwxr-xr-x 135 root root 12288 2010-09-23 18:49 .. </span><br><span class="line">-rw-r--r--   1 root root   220 2010-04-18 21:51 .bash_logout </span><br><span class="line">-rw-r--r--   1 root root  3103 2010-04-18 21:51 .bashrc </span><br><span class="line">-rw-r--r--   1 root root   179 2010-03-26 08:31 examples.desktop </span><br><span class="line">-rw-r--r--   1 root root   675 2010-04-18 21:51 .profile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -m  创建用户的HOME目录</span></span><br><span class="line">useradd -m <span class="built_in">test</span></span><br><span class="line">-c comment  给新用户添加备注 </span><br><span class="line">-d home_dir  为主目录指定一个名字（如果不想用登录名作为主目录名的话） </span><br><span class="line">-e expire_date  用YYYY-MM-DD格式指定一个账户过期的日期 </span><br><span class="line">-f inactive_days  指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示</span><br><span class="line">禁用这个功能 </span><br><span class="line">-g initial_group  指定用户登录组的GID或组名 </span><br><span class="line">-G group ...  指定用户除登录组之外所属的一个或多个附加组 </span><br><span class="line">-k  必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录 </span><br><span class="line">-m  创建用户的HOME目录 </span><br><span class="line">-M  不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） </span><br><span class="line">-n  创建一个与用户登录名同名的新组 </span><br><span class="line">-r  创建系统账户 </span><br><span class="line">-p passwd  为用户账户指定默认密码 </span><br><span class="line">-s shell  指定默认的登录shell </span><br><span class="line">-u uid  为账户指定唯一的UID</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd -D -s /bin/tsch </span></span><br><span class="line">useradd更改默认值的参数 </span><br><span class="line">-b default_home  更改默认的创建用户HOME目录的位置 </span><br><span class="line">-e expiration_date  更改默认的新账户的过期日期 </span><br><span class="line">-f inactive  更改默认的新用户从密码过期到账户被禁用的天数 </span><br><span class="line">-g group  更改默认的组名称或GID </span><br><span class="line">-s shell  更改默认的登录shell</span><br></pre></td></tr></table></figure>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>默认情况下， <code>userdel</code>命令会只删除<code>/etc/passwd</code>文件中的用户信息，而不会删除系统中属于该账户的任何文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除用户的HOME目录以及邮件目录</span></span><br><span class="line">userdel -r <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usermod <span class="comment"># 修改用户账户的字段，还可以指定主要组以及附加组的所属关系</span></span><br><span class="line">passwd <span class="comment"># 修改已有用户的密码</span></span><br><span class="line">chpasswd <span class="comment"># 从文件中读取登录名密码对，并更新密码</span></span><br><span class="line">chage <span class="comment"># 修改密码的过期日期</span></span><br><span class="line">chfn <span class="comment"># 修改用户账户的备注信息</span></span><br><span class="line">chsh <span class="comment"># 修改用户账户的默认登录shell</span></span><br></pre></td></tr></table></figure>
<h5 id="1-usermod"><a href="#1-usermod" class="headerlink" title="1.usermod"></a>1.<code>usermod</code></h5><p><code>usermod</code> 命令是用户账户修改工具中最强大的一个。参数大部分跟 useradd 命令的参数一样.</p>
<p>-g 修改默认的登录组<br>-l  修改用户账户的登录名。<br>-L 锁定账户，使用户无法登录。<br>-p 修改账户的密码。<br>-U 解除锁定，使用户能够登录。</p>
<h5 id="2-passwd和chpasswd"><a href="#2-passwd和chpasswd" class="headerlink" title="2.passwd和chpasswd"></a>2.<code>passwd</code>和<code>chpasswd</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改密码</span></span><br><span class="line"><span class="comment"># passwd test</span></span><br><span class="line">Changing password <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">New UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<p>如果只用<code>passwd</code>命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只有root用户才有权限改别人的密码。<br>-e 选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制在下次登录时改成他们能记住的更复杂的密码。</p>
<p>如果需要为系统中的大量用户修改密码，<code>chpasswd</code>命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。<br>你也可以用重定向命令来将含有<code>userid:passwd</code> 对的文件重定向给该命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chpasswd &lt; users.txt</span><br></pre></td></tr></table></figure></p>
<h5 id="3-chsh、chfn和chage"><a href="#3-chsh、chfn和chage" class="headerlink" title="3.chsh、chfn和chage"></a>3.<code>chsh</code>、<code>chfn</code>和<code>chage</code></h5><p><code>chsh</code>、 <code>chfn</code> 和 <code>chage</code> 工具专门用来修改特定的账户信息<br><code>chsh</code> 命令用来快速修改默认的用户登录shell。使用时必须用shell的全路径名作为参数，不能只用shell名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/csh <span class="built_in">test</span></span><br><span class="line">Changing shell <span class="keyword">for</span> <span class="built_in">test</span>.</span><br><span class="line">Shell changed.</span><br></pre></td></tr></table></figure>
<p><code>chfn</code> 命令提供了在<code>/etc/passwd</code>文件的备注字段中存储信息的标准方法。 <code>chfn</code> 命令会将用于<br>Unix的<code>finger</code> 命令的信息存进备注字段，而不是简单地存入一些随机文本（比如名字或昵称之类的），或是将备注字段留空。</p>
<p><code>finger</code>命令可以非常方便地查看Linux系统上的用户信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># finger rich</span></span><br><span class="line">Login: rich                            Name: Rich Blum</span><br><span class="line">Directory: /home/rich                  Shell: /bin/bash</span><br><span class="line">On since Thu Sep 20 18:03 (EDT) on pts/0 from 192.168.1.2</span><br><span class="line">No mail.</span><br><span class="line">No Plan.</span><br></pre></td></tr></table></figure></p>
<p>如果在使用 <code>chfn</code>命令时没有参数，它会向你询问要将哪些适合的内容加进备注字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chfn <span class="built_in">test</span></span><br><span class="line">Changing finger information <span class="keyword">for</span> <span class="built_in">test</span>.</span><br><span class="line">Name []: Ima Test</span><br><span class="line">Office []: Director of Technology</span><br><span class="line">Office Phone []: (123)555-1234</span><br><span class="line">Home Phone []: (123)555-9876</span><br></pre></td></tr></table></figure></p>
<p><code>chage</code> 命令用来帮助管理用户账户的有效期</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d  设置上次修改密码到现在的天数 </span><br><span class="line">-E  设置密码过期的日期 </span><br><span class="line">-I  设置密码过期到锁定账户的天数 </span><br><span class="line">-m  设置修改密码之间最少要多少天 </span><br><span class="line">-W  设置密码过期前多久开始出现提醒信息</span><br></pre></td></tr></table></figure>
<h2 id="Linux-组"><a href="#Linux-组" class="headerlink" title="Linux 组"></a>Linux 组</h2><p>组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。Ubuntu就会为每个用户创建一个单独的与用户账户同名的组。在添加用户前后可用 <code>grep</code> 命令或 <code>tail</code> 命令<br>查看/etc/group文件的内容比较（<code>grep USERNAME  /etc/group 或 tail /etc/group</code> ）。</p>
<h4 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a><code>/etc/group</code>文件</h4><p>/etc/group文件包含系统上用到的每个组的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:root</span><br><span class="line">bin:x:1:root,bin,daemon</span><br><span class="line">daemon:x:2:root,bin,daemon</span><br><span class="line">sys:x:3:root,bin,adm</span><br><span class="line">jessica:x:503:</span><br><span class="line">mysql:x:27:</span><br><span class="line"><span class="built_in">test</span>:x:504:</span><br><span class="line">----------------------</span><br><span class="line">系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配。</span><br><span class="line">/etc/group文件有4个字段：</span><br><span class="line">组名</span><br><span class="line">组密码</span><br><span class="line">GID</span><br><span class="line">属于该组的用户列表</span><br></pre></td></tr></table></figure>
<h4 id="创建新组-groupadd"><a href="#创建新组-groupadd" class="headerlink" title="创建新组(groupadd)"></a>创建新组(groupadd)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin/groupadd shared </span></span><br><span class="line"><span class="comment"># tail /etc/group </span></span><br><span class="line">shared:x:505:</span><br></pre></td></tr></table></figure>
<p>在创建新组时，默认没有用户被分配到该组。<code>groupadd</code>命令没有提供将用户添加到组中的<br>选项，但可以用 <code>usermod</code> 命令来弥补这一点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -G shared rich</span></span><br><span class="line"><span class="comment"># usermod -G shared test</span></span><br><span class="line">-g 指定的组名会替换掉该账户的默认组。</span><br><span class="line">-G 将该组添加到用户的属组的列表里，不会影响默认组。</span><br><span class="line"><span class="comment"># tail /etc/group </span></span><br><span class="line">shared:x:505:rich, <span class="built_in">test</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更改才能生效。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="修改组-groupmod"><a href="#修改组-groupmod" class="headerlink" title="修改组(groupmod)"></a>修改组(groupmod)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin/groupmod -n sharing shared  </span></span><br><span class="line">-g 修改已有组的GID</span><br><span class="line">-n 修改组名</span><br><span class="line"><span class="comment"># tail /etc/group </span></span><br><span class="line">sharing:x:505:<span class="built_in">test</span>,rich</span><br></pre></td></tr></table></figure>
<h2 id="理解文件权限"><a href="#理解文件权限" class="headerlink" title="理解文件权限"></a>理解文件权限</h2><h3 id="使用文件权限符"><a href="#使用文件权限符" class="headerlink" title="使用文件权限符"></a>使用文件权限符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ ls –l </span><br><span class="line">-rw-rw-r-- 1 rich rich  50 2010-09-13 07:49 file1.gz</span><br><span class="line">drwxrwxr-x 2 rich rich 4096 2010-09-03 15:12 test1</span><br><span class="line">$</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：</span><br><span class="line">- 代表文件</span><br><span class="line">d 代表目录</span><br><span class="line">l 代表链接</span><br><span class="line">c 代表字符型设备</span><br><span class="line">b 代表块设备</span><br><span class="line">n 代表网络设备</span><br><span class="line">之后有3组三字符的编码。每一组定义了3种访问权限：</span><br><span class="line">r 代表对象是可读的</span><br><span class="line">w 代表对象是可写的</span><br><span class="line">x 代表对象是可执行的</span><br><span class="line">若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：</span><br><span class="line">对象的属主</span><br><span class="line">对象的属组</span><br><span class="line">系统其他用户</span><br><span class="line"> </span><br><span class="line">-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog</span><br><span class="line">文件myprog有下面3组权限。</span><br><span class="line">rwx ：文件的属主（设为登录名rich）。</span><br><span class="line">rwx ：文件的属组（设为组名rich）。</span><br><span class="line">r-x ：系统上其他人。</span><br></pre></td></tr></table></figure>
<h3 id="默认文件权限"><a href="#默认文件权限" class="headerlink" title="默认文件权限"></a>默认文件权限</h3><p><code>umask</code> 命令用来设置所创建文件和目录的默认权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch 命令用分配给我的用户账户的默认权限创建了这个文件</span></span><br><span class="line">$ touch newfile </span><br><span class="line">$ ls -al newfile </span><br><span class="line">-rw-r--r--    1 rich     rich            0 Sep 20 19:16 newfile </span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># umask</span></span><br><span class="line">0022</span><br></pre></td></tr></table></figure>
<p><code>umask</code> 值只是个掩码。它会屏蔽掉不想授予该安全级别的权限,要把 <code>umask</code> 值从对象的全权限值中减掉。对文件来说，全权限的值是 666 （所有用户都有读和写的权限）；而对目录来说，则是 777 （所有用户都有读、写、执行权限）</p>
<h2 id="改变安全性设置"><a href="#改变安全性设置" class="headerlink" title="改变安全性设置"></a>改变安全性设置</h2><h3 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h3><p><code>chmod</code>命令用来改变文件和目录的安全性设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">chmod options mode file </span><br><span class="line">-R 让权限的改变递归地作用到文件和子目录。你可以使用通配符指定多个文件，然后利用一条命令将权限更改应用到这些文件上。</span><br><span class="line"></span><br><span class="line"><span class="comment"># mode 参数可以使用八进制模式或符号模式进行安全性设置。</span></span><br><span class="line"><span class="comment"># 1.八进制模式 设置非常直观，直接用期望赋予文件的标准3位八进制权限码即可。</span></span><br><span class="line">$ chmod 760 newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rwxrw----    1 rich    rich            0 Sep 20 19:16 newfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.符号模式下指定权限的格式:</span></span><br><span class="line">[ugoa…][[+-=][rwxXstugo…]</span><br><span class="line">第一组字符定义了权限作用的对象：</span><br><span class="line">u 代表用户</span><br><span class="line">g 代表组</span><br><span class="line">o 代表其他</span><br><span class="line">a 代表上述所有</span><br><span class="line">下一步，后面跟着的符号表示你是想在现有权限基础上增加权限(+)，还是在现有权限基础上移除权限(-)，或是将权限设置成后面的值(=)。</span><br><span class="line">第三个符号代表作用到设置上的权限。额外的设置有以下几项:</span><br><span class="line">X ：如果对象是目录或者它已有执行权限，赋予执行权限。</span><br><span class="line">s ：运行时重新设置UID或GID。</span><br><span class="line">t ：保留文件或目录。</span><br><span class="line">u ：将权限设置为跟属主一样。</span><br><span class="line">g ：将权限设置为跟属组一样。</span><br><span class="line">o ：将权限设置为跟其他用户一样。</span><br><span class="line">$ chmod o+r newfile</span><br><span class="line"><span class="comment">#ls -F 它能够在具有执行权限的文件名后加一个星号</span></span><br><span class="line">$ ls -lF newfile</span><br><span class="line">-rwxrw-r--    1 rich    rich            0 Sep 20 19:16 newfile*</span><br></pre></td></tr></table></figure>
<p>options 为 chmod 命令提供了另外一些功能。 </p>
<h3 id="改变所属关系"><a href="#改变所属关系" class="headerlink" title="改变所属关系"></a>改变所属关系</h3><p><code>chown</code>改变文件的属主<br><code>chgrp</code>改变文件的默认属组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown 命令的格式如下</span></span><br><span class="line">chown options owner[.group] file</span><br><span class="line">-R 选项配合通配符可以递归地改变子目录和文件的所属关系。 </span><br><span class="line">-h 选项可以改变该文件的所有符号链接文件的所属关系</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时改变所在属主和属组</span></span><br><span class="line"><span class="comment"># chown dan.shared newfile </span></span><br><span class="line"><span class="comment"># ls -l newfile </span></span><br><span class="line">-rw-rw-r--    1 dan      shared             0 Sep 20 19:16 newfile </span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chgrp命令可以更改文件或目录的默认属组,用户账户必须是这个文件的属主，除了能够更换属组之外，还得是新组的成员.</span></span><br><span class="line">$ chgrp shared newfile</span><br><span class="line">$ ls -l newfile</span><br><span class="line">-rw-rw-r--    1 rich    shared          0 Sep 20 19:16 newfile</span><br></pre></td></tr></table></figure>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>Linux系统上共享文件的方法是创建组<br>Linux还为每个文件和目录存储了3个额外的信息位。<br>设置用户ID（<code>SUID</code>）：当文件被用户使用时，程序会以文件属主的权限运行。<br>设置组ID（<code>SGID</code>）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。<br>粘着位：进程结束后文件还驻留（粘着）在内存中。</p>
<p><code>SGID</code>位对文件共享非常重要。启用<code>SGID</code>位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir testdir</span><br><span class="line">$ ls -l</span><br><span class="line">drwxrwxr-x    2 rich    rich        4096 Sep 20 23:12 testdir/</span><br><span class="line">$ chgrp shared testdir</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod g+s testdir  <span class="comment">#将目录的SGID位置位，以保证目录中新建文件都用shared作为默认属组</span></span><br><span class="line">$ ls -l</span><br><span class="line">drwxrwsr-x    2 rich    shared      4096 Sep 20 23:12 testdir/</span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/16/linux-cmd-3-linux-file-permissions/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2018-02-15 </div>
			<div class="article-title"><a href="/2018/02/15/linux-cmd-2-linux-enviroment/" >Linux命令行(2)Linux环境变量</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>全局环境变量对于shell会话和所有生成的子shell都是可见的，局部变量则只对创建它们的shell可见。</p>
<h3 id="查看全局变量"><a href="#查看全局变量" class="headerlink" title="查看全局变量"></a>查看全局变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env 或 printenv</span><br></pre></td></tr></table></figure>
<h3 id="显示个别环境变量的值"><a href="#显示个别环境变量的值" class="headerlink" title="显示个别环境变量的值"></a>显示个别环境变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printenv HOME</span><br></pre></td></tr></table></figure>
<p>也可以使用 echo 显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面加上一个美元符($)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>
<p>在 echo 命令中，在变量名前加上 $ 可不仅仅是要显示变量当前的值。它能够让变量作为命令行参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>
<h2 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h2><p>局部环境变量只能在定义它们的进程中可见。在Linux系统并没有一个只显示局部环境变量的命令,<code>set</code>命令 显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">set</span> </span><br><span class="line">BASH=/bin/bash </span><br><span class="line">[...] </span><br><span class="line">BASH_ALIASES=() </span><br><span class="line">BASH_ARGC=() </span><br><span class="line">BASH_ARGV=() </span><br><span class="line">BASH_CMDS=() </span><br><span class="line">BASH_LINENO=() </span><br><span class="line">BASH_SOURCE=() </span><br><span class="line">[...] </span><br><span class="line">colors=/etc/DIR_COLORS </span><br><span class="line">my_variable=<span class="string">'Hello World'</span> </span><br><span class="line">[...] </span><br><span class="line">$ </span><br><span class="line"><span class="comment">#可以看到，所有通过printenv 命令能看到的全局环境变量都出现在了 set 命令的输出中。但在 set 命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量。</span></span><br></pre></td></tr></table></figure>
<h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h3><h4 id="设置局部用户定义变量"><a href="#设置局部用户定义变量" class="headerlink" title="设置局部用户定义变量"></a>设置局部用户定义变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line"></span><br><span class="line">$ my_variable=<span class="string">"Hello World"</span>  <span class="comment"># 值可以是数值或字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子shell无法访问父shell定义的局部变量</span></span><br><span class="line">$ bash </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">Hello World </span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: 局部环境变量使用小写字母，系统环境变量使用大写字母</span></span><br><span class="line"><span class="comment"># 变量名、等号和值之间没有空格,。如果在赋值表达式中加上了空格，bash  shell就会把值当成一个单独的命令</span></span><br><span class="line">$ my_variable = <span class="string">"Hello World"</span> </span><br><span class="line">-bash: my_variable: <span class="built_in">command</span> not found </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h4 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h4><p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过<code>export</code> 命令使其变成了全局环境变量，子shell甚至无法使用 export 命令改变父shell中全局环境变量的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ my_variable=<span class="string">"I am Global now"</span></span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">export</span> my_variable</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ bash </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line">I am Global now</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">unset</span> my_variable</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你是在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。</span></span><br><span class="line">$ my_variable=<span class="string">"I am Global now"</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">export</span> my_variable </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ bash </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">unset</span> my_variable </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">exit</span> </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$my_variable</span> </span><br><span class="line">I am Global now </span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>如果要用到变量，使用<code>$</code>如果要操作变量，不使用<code>$</code>。这条规则的一个例外就是使用 printenv 显示某个变量的值。</p>
<h2 id="默认的-shell-环境变量"><a href="#默认的-shell-环境变量" class="headerlink" title="默认的 shell 环境变量"></a>默认的 shell 环境变量</h2><p>默认情况下，bash  shell会用一些特定的环境变量来定义系统环境。bash shell源自当初的Unix Bourne shell，因此也保留了Unix Bourne shell里定义的那些环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash shell支持的Bourne变量(部分)</span></span><br><span class="line">HOME  当前用户的主目录 </span><br><span class="line">IFS  shell用来将文本字符串分割成字段的一系列字符 </span><br><span class="line">OPTARG  <span class="built_in">getopts</span>命令处理的最后一个选项参数值 </span><br><span class="line">OPTIND  <span class="built_in">getopts</span>命令处理的最后一个选项参数的索引号 </span><br><span class="line">PATH  shell查找命令的目录列表，由冒号分隔 </span><br><span class="line">PS1  shell命令行界面的主提示符 </span><br><span class="line">PS2  shell命令行界面的次提示符 </span><br><span class="line"></span><br><span class="line"><span class="comment"># bash shell环境变量(部分)</span></span><br><span class="line">BASH  当前shell实例的全路径名 </span><br><span class="line">BASH_COMMAND  shell正在执行的命令或马上就执行的命令 </span><br><span class="line">BASH_VERSION  当前运行的bash shell的版本号 </span><br><span class="line">BASHPID  当前bash进程的PID </span><br><span class="line">ENV  如果设置了该环境变量，在bash  shell脚本运行之前会先执行已定义的启动文件（仅用于当bash shell以POSIX模式被调用时） </span><br><span class="line">FUNCNAME  当前执行的shell函数的名称</span><br><span class="line">GROUPS  含有当前用户属组列表的数组变量 </span><br><span class="line">HISTSIZE  最多在历史文件中存多少条命令 </span><br><span class="line">HOSTFILE  shell在补全主机名时读取的文件名称 </span><br><span class="line">HOSTNAME  当前主机的名称 </span><br><span class="line">HOSTTYPE  当前运行bash shell的机器 </span><br><span class="line">LANG  shell的语言环境类别</span><br><span class="line">PPID  bash shell父进程的PID </span><br><span class="line">PWD  当前工作目录 </span><br><span class="line">RANDOM  返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子） </span><br><span class="line">SHELL  bash shell的全路径名 </span><br><span class="line">TMPDIR  目录名，保存bash shell创建的临时文件 </span><br><span class="line">UID  当前用户的真实用户ID（数字形式）</span><br></pre></td></tr></table></figure>
<h2 id="设置-PATH-环境变量"><a href="#设置-PATH-环境变量" class="headerlink" title="设置 PATH 环境变量"></a>设置 PATH 环境变量</h2><p>当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。 PATH 环境变量定义了用于进行命令和程序查找的目录,PATH 中的目录使用冒号分隔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu PATH</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> </span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin: </span><br><span class="line">/sbin:/bin:/usr/games:/usr/<span class="built_in">local</span>/games </span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果命令或者程序的位置没有包括在 PATH 变量中，那么如果不使用绝对路径的话，shell是没法找到的。如果shell找不到指定的命令或程序，它会产生一个错误信息</span></span><br><span class="line">$ myprog </span><br><span class="line">-bash: myprog: <span class="built_in">command</span> not found </span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用原来的 PATH 值，然后再给这个字符串添加新目录</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/christine/Scripts</span><br><span class="line"><span class="comment"># 如果希望子shell也能找到你的程序的位置，一定要记得把修改后的 PATH 环境变量导出</span></span><br></pre></td></tr></table></figure>
<h2 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h2><p>在你登入Linux系统启动一个bash  shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash  shell的方式。启动bash shell有3种方式： </p>
<ol>
<li>登录时作为默认登录shell</li>
<li>作为非登录shell的交互式shell </li>
<li>作为运行脚本的非交互shell </li>
</ol>
<h3 id="1-登录时作为默认登录shell"><a href="#1-登录时作为默认登录shell" class="headerlink" title="1.登录时作为默认登录shell"></a>1.登录时作为默认登录shell</h3><p>当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里读取命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile </span><br><span class="line"><span class="variable">$HOME</span>/.bash_profile </span><br><span class="line"><span class="variable">$HOME</span>/.bashrc </span><br><span class="line"><span class="variable">$HOME</span>/.bash_login </span><br><span class="line"><span class="variable">$HOME</span>/.profile</span><br></pre></td></tr></table></figure></p>
<p><code>/etc/profile</code>文件是系统上默认的bash  shell的主启动文件。系统上的每个用户登录时都会执行这个启动文件,另外4个启动文件是针对用户的，可根据个人需求定制。</p>
<h4 id="etc-profile文件"><a href="#etc-profile文件" class="headerlink" title="/etc/profile文件"></a>/etc/profile文件</h4><p>/etc/profile文件是bash  shell默认的的主启动文件。只要你登录了Linux系统，bash就会执行/etc/profile启动文件中的命令。不同的Linux发行版在这个文件里放了不同的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos</span></span><br><span class="line"><span class="comment"># /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># System wide environment and startup programs, for login setup</span></span><br><span class="line"><span class="comment"># Functions and aliases go in /etc/bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It's NOT a good idea to change this file unless you know what you</span></span><br><span class="line"><span class="comment"># are doing. It's much better to create a custom.sh shell script in</span></span><br><span class="line"><span class="comment"># /etc/profile.d/ to make custom changes to your environment, as this</span></span><br><span class="line"><span class="comment"># will prevent the need for merging in future updates.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pathmunge</span></span> () &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">":<span class="variable">$&#123;PATH&#125;</span>:"</span> <span class="keyword">in</span></span><br><span class="line">        *:<span class="string">"<span class="variable">$1</span>"</span>:*)</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"<span class="variable">$2</span>"</span> = <span class="string">"after"</span> ] ; <span class="keyword">then</span></span><br><span class="line">                PATH=<span class="variable">$PATH</span>:<span class="variable">$1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                PATH=<span class="variable">$1</span>:<span class="variable">$PATH</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/id ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$EUID</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># ksh workaround</span></span><br><span class="line">        EUID=`id -u`</span><br><span class="line">        UID=`id -ru`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    USER=<span class="string">"`id -un`"</span></span><br><span class="line">    LOGNAME=<span class="variable">$USER</span></span><br><span class="line">    MAIL=<span class="string">"/var/spool/mail/<span class="variable">$USER</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path manipulation</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$EUID</span>"</span> = <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    pathmunge /sbin</span><br><span class="line">    pathmunge /usr/sbin</span><br><span class="line">    pathmunge /usr/<span class="built_in">local</span>/sbin</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pathmunge /usr/<span class="built_in">local</span>/sbin after</span><br><span class="line">    pathmunge /usr/sbin after</span><br><span class="line">    pathmunge /sbin after</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">HOSTNAME=`/bin/hostname 2&gt;/dev/null`</span><br><span class="line">HISTSIZE=1000</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HISTCONTROL</span>"</span> = <span class="string">"ignorespace"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> HISTCONTROL=ignoreboth</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">export</span> HISTCONTROL=ignoredups</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, we want umask to get set. This sets it for login shell</span></span><br><span class="line"><span class="comment"># Current threshold for system reserved uid/gids is 200</span></span><br><span class="line"><span class="comment"># You could check uidgid reservation validity in</span></span><br><span class="line"><span class="comment"># /usr/share/doc/setup-*/uidgid file</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">"`id -gn`"</span> = <span class="string">"`id -un`"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$i</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;-#*i&#125;</span>"</span> != <span class="string">"$-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            . <span class="string">"<span class="variable">$i</span>"</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> i</span><br><span class="line"><span class="built_in">unset</span> -f pathmunge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明 ubuntu和centos两个发行版的/etc/profile文件都有： for 语句。它用来迭代/etc/profile.d目录下的所有文件。）这为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件</span></span><br><span class="line">$ ls -l /etc/profile.d </span><br><span class="line">total 80 </span><br><span class="line">-rw-r--r--. 1 root root 1127 Mar  5 07:17 colorls.csh </span><br><span class="line">-rw-r--r--. 1 root root 1143 Mar  5 07:17 colorls.sh </span><br><span class="line">-rw-r--r--. 1 root root   92 Nov 22  2013 cvs.csh </span><br><span class="line"></span><br><span class="line">不难发现，有些文件与系统中的特定应用有关。大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。 lang.csh和lang.sh文件会尝试去判定系统上所采用的默认语言字符集，然后设置对应的 LANG环境变量。</span><br></pre></td></tr></table></figure>
<h4 id="HOME目录下的启动文件"><a href="#HOME目录下的启动文件" class="headerlink" title="$HOME目录下的启动文件"></a>$HOME目录下的启动文件</h4><p>剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/.bash_profile</span><br><span class="line"><span class="variable">$HOME</span>/.bashrc</span><br><span class="line"><span class="variable">$HOME</span>/.bash_login</span><br><span class="line"><span class="variable">$HOME</span>/.profile</span><br></pre></td></tr></table></figure>
<p>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/.bash_profile</span><br><span class="line"><span class="variable">$HOME</span>/.bash_login</span><br><span class="line"><span class="variable">$HOME</span>/.profile</span><br></pre></td></tr></table></figure>
<p>注意，这个列表中并没有<code>$HOME/.bashrc</code>文件。这是因为该文件通常通过其他文件运行的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">	. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># .bash_profile启动文件会先去检查HOME目录中是不是还有一个叫.bashrc的启动文件。如果有的话，会先执行启动文件里面的命令</span></span><br></pre></td></tr></table></figure>
<h3 id="2-作为非登录shell的交互式shell"><a href="#2-作为非登录shell的交互式shell" class="headerlink" title="2.作为非登录shell的交互式shell"></a>2.作为非登录shell的交互式shell</h3><p>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入 bash 时启动），那么你启动的shell叫作交互式shell。交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。<br>如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -i'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -i'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">	. /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># .bashrc文件有两个作用：一是查看/etc目录下通用的bashrc文件，二是为用户提供一个定制自己的命令别名和私有脚本函数的地方。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-作为运行脚本的非交互shell"><a href="#3-作为运行脚本的非交互shell" class="headerlink" title="3.作为运行脚本的非交互shell"></a>3.作为运行脚本的非交互shell</h3><p>当shell启动一个非交互式shell进程时，它会检查 BASH_ENV 环境变量来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。 </p>
<p>如果父shell是登录shell，在/etc/profile、/etc/profile.d/ * .sh和$HOME/.bashrc文件中设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。 </p>
<h3 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h3><p>对全局环境变量来说（Linux系统中所有用户都需要使用的变量），最好是在<code>/etc/profile.d</code>目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。<br>对个人用户永久性bash shell变量应该放在<code>$HOME/.bashrc</code>文件。</p>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔</span></span><br><span class="line">mytest=(one two three four five)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$mytest</span></span><br><span class="line">one</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span></span><br><span class="line">three</span><br><span class="line"><span class="comment"># 要显示整个数组变量，可用星号作为通配符放在索引值的位置</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[*]&#125;</span></span><br><span class="line">one two three four five</span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">mytest[2]=seven</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">$ <span class="built_in">unset</span> mytest[2] </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[*]&#125;</span> </span><br><span class="line">one two four five </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span> </span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[3]&#125;</span> </span><br><span class="line">four </span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line">$ <span class="built_in">unset</span> mytest </span><br><span class="line">$ </span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;mytest[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>

	
	</div>
  <a type="button" href="/2018/02/15/linux-cmd-2-linux-enviroment/#more" class="btn btn-default more">阅读此文</a>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
        

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/2/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Shell/">Shell<span>11</span></a></li>
		
			<li><a href="/tags/Linux/">Linux<span>11</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/02/24/shell-script-6-function/" ><i class="fa fa-file-o"></i>shell脚本(6)创建函数</a>
      </li>
    
      <li>
        <a href="/2018/02/23/shell-script-5-script-control/" ><i class="fa fa-file-o"></i>shell脚本(5)控制脚本</a>
      </li>
    
      <li>
        <a href="/2018/02/22/shell-script-4-presenting-data/" ><i class="fa fa-file-o"></i>shell脚本(4)呈现数据</a>
      </li>
    
      <li>
        <a href="/2018/02/21/shell-script-3-user-input/" ><i class="fa fa-file-o"></i>shell脚本(3)处理用户输入</a>
      </li>
    
      <li>
        <a href="/2018/02/20/shell-script-2-structed-command/" ><i class="fa fa-file-o"></i>shell脚本(2)结构化命令</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/technonac" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 technonac
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>
